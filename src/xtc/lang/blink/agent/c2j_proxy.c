/* This source file is generated by GenerateJNIFunctionProxy.java
Please, do not edit manually.*/
#include <string.h>
#include <assert.h>
#include <jni.h>
#include <jvmti.h>
#include "agent_main.h"
#include "state.h"
#include "common.h"
#include "agent.h"
#include "options.h"
#include "java_method.h"
#include "jnicheck.h"
#include "classfile_constants.h"

static jniNativeInterface* proxy_jni_funcs = NULL;
struct bda_c2j_stat_count_jint {
  jint GetVersion;
  jint DefineClass;
  jint FindClass;
  jint FromReflectedMethod;
  jint FromReflectedField;
  jint ToReflectedMethod;
  jint GetSuperclass;
  jint IsAssignableFrom;
  jint ToReflectedField;
  jint Throw;
  jint ThrowNew;
  jint ExceptionOccurred;
  jint ExceptionDescribe;
  jint ExceptionClear;
  jint FatalError;
  jint PushLocalFrame;
  jint PopLocalFrame;
  jint NewGlobalRef;
  jint DeleteGlobalRef;
  jint DeleteLocalRef;
  jint IsSameObject;
  jint NewLocalRef;
  jint EnsureLocalCapacity;
  jint AllocObject;
  jint NewObject;
  jint NewObjectV;
  jint NewObjectA;
  jint GetObjectClass;
  jint IsInstanceOf;
  jint GetMethodID;
  jint CallObjectMethod;
  jint CallObjectMethodV;
  jint CallObjectMethodA;
  jint CallBooleanMethod;
  jint CallBooleanMethodV;
  jint CallBooleanMethodA;
  jint CallByteMethod;
  jint CallByteMethodV;
  jint CallByteMethodA;
  jint CallCharMethod;
  jint CallCharMethodV;
  jint CallCharMethodA;
  jint CallShortMethod;
  jint CallShortMethodV;
  jint CallShortMethodA;
  jint CallIntMethod;
  jint CallIntMethodV;
  jint CallIntMethodA;
  jint CallLongMethod;
  jint CallLongMethodV;
  jint CallLongMethodA;
  jint CallFloatMethod;
  jint CallFloatMethodV;
  jint CallFloatMethodA;
  jint CallDoubleMethod;
  jint CallDoubleMethodV;
  jint CallDoubleMethodA;
  jint CallVoidMethod;
  jint CallVoidMethodV;
  jint CallVoidMethodA;
  jint CallNonvirtualObjectMethod;
  jint CallNonvirtualObjectMethodV;
  jint CallNonvirtualObjectMethodA;
  jint CallNonvirtualBooleanMethod;
  jint CallNonvirtualBooleanMethodV;
  jint CallNonvirtualBooleanMethodA;
  jint CallNonvirtualByteMethod;
  jint CallNonvirtualByteMethodV;
  jint CallNonvirtualByteMethodA;
  jint CallNonvirtualCharMethod;
  jint CallNonvirtualCharMethodV;
  jint CallNonvirtualCharMethodA;
  jint CallNonvirtualShortMethod;
  jint CallNonvirtualShortMethodV;
  jint CallNonvirtualShortMethodA;
  jint CallNonvirtualIntMethod;
  jint CallNonvirtualIntMethodV;
  jint CallNonvirtualIntMethodA;
  jint CallNonvirtualLongMethod;
  jint CallNonvirtualLongMethodV;
  jint CallNonvirtualLongMethodA;
  jint CallNonvirtualFloatMethod;
  jint CallNonvirtualFloatMethodV;
  jint CallNonvirtualFloatMethodA;
  jint CallNonvirtualDoubleMethod;
  jint CallNonvirtualDoubleMethodV;
  jint CallNonvirtualDoubleMethodA;
  jint CallNonvirtualVoidMethod;
  jint CallNonvirtualVoidMethodV;
  jint CallNonvirtualVoidMethodA;
  jint GetFieldID;
  jint GetObjectField;
  jint GetBooleanField;
  jint GetByteField;
  jint GetCharField;
  jint GetShortField;
  jint GetIntField;
  jint GetLongField;
  jint GetFloatField;
  jint GetDoubleField;
  jint SetObjectField;
  jint SetBooleanField;
  jint SetByteField;
  jint SetCharField;
  jint SetShortField;
  jint SetIntField;
  jint SetLongField;
  jint SetFloatField;
  jint SetDoubleField;
  jint GetStaticMethodID;
  jint CallStaticObjectMethod;
  jint CallStaticObjectMethodV;
  jint CallStaticObjectMethodA;
  jint CallStaticBooleanMethod;
  jint CallStaticBooleanMethodV;
  jint CallStaticBooleanMethodA;
  jint CallStaticByteMethod;
  jint CallStaticByteMethodV;
  jint CallStaticByteMethodA;
  jint CallStaticCharMethod;
  jint CallStaticCharMethodV;
  jint CallStaticCharMethodA;
  jint CallStaticShortMethod;
  jint CallStaticShortMethodV;
  jint CallStaticShortMethodA;
  jint CallStaticIntMethod;
  jint CallStaticIntMethodV;
  jint CallStaticIntMethodA;
  jint CallStaticLongMethod;
  jint CallStaticLongMethodV;
  jint CallStaticLongMethodA;
  jint CallStaticFloatMethod;
  jint CallStaticFloatMethodV;
  jint CallStaticFloatMethodA;
  jint CallStaticDoubleMethod;
  jint CallStaticDoubleMethodV;
  jint CallStaticDoubleMethodA;
  jint CallStaticVoidMethod;
  jint CallStaticVoidMethodV;
  jint CallStaticVoidMethodA;
  jint GetStaticFieldID;
  jint GetStaticObjectField;
  jint GetStaticBooleanField;
  jint GetStaticByteField;
  jint GetStaticCharField;
  jint GetStaticShortField;
  jint GetStaticIntField;
  jint GetStaticLongField;
  jint GetStaticFloatField;
  jint GetStaticDoubleField;
  jint SetStaticObjectField;
  jint SetStaticBooleanField;
  jint SetStaticByteField;
  jint SetStaticCharField;
  jint SetStaticShortField;
  jint SetStaticIntField;
  jint SetStaticLongField;
  jint SetStaticFloatField;
  jint SetStaticDoubleField;
  jint NewString;
  jint GetStringLength;
  jint GetStringChars;
  jint ReleaseStringChars;
  jint NewStringUTF;
  jint GetStringUTFLength;
  jint GetStringUTFChars;
  jint ReleaseStringUTFChars;
  jint GetArrayLength;
  jint NewObjectArray;
  jint GetObjectArrayElement;
  jint SetObjectArrayElement;
  jint NewBooleanArray;
  jint NewByteArray;
  jint NewCharArray;
  jint NewShortArray;
  jint NewIntArray;
  jint NewLongArray;
  jint NewFloatArray;
  jint NewDoubleArray;
  jint GetBooleanArrayElements;
  jint GetByteArrayElements;
  jint GetCharArrayElements;
  jint GetShortArrayElements;
  jint GetIntArrayElements;
  jint GetLongArrayElements;
  jint GetFloatArrayElements;
  jint GetDoubleArrayElements;
  jint ReleaseBooleanArrayElements;
  jint ReleaseByteArrayElements;
  jint ReleaseCharArrayElements;
  jint ReleaseShortArrayElements;
  jint ReleaseIntArrayElements;
  jint ReleaseLongArrayElements;
  jint ReleaseFloatArrayElements;
  jint ReleaseDoubleArrayElements;
  jint GetBooleanArrayRegion;
  jint GetByteArrayRegion;
  jint GetCharArrayRegion;
  jint GetShortArrayRegion;
  jint GetIntArrayRegion;
  jint GetLongArrayRegion;
  jint GetFloatArrayRegion;
  jint GetDoubleArrayRegion;
  jint SetBooleanArrayRegion;
  jint SetByteArrayRegion;
  jint SetCharArrayRegion;
  jint SetShortArrayRegion;
  jint SetIntArrayRegion;
  jint SetLongArrayRegion;
  jint SetFloatArrayRegion;
  jint SetDoubleArrayRegion;
  jint RegisterNatives;
  jint UnregisterNatives;
  jint MonitorEnter;
  jint MonitorExit;
  jint GetJavaVM;
  jint GetStringRegion;
  jint GetStringUTFRegion;
  jint GetPrimitiveArrayCritical;
  jint ReleasePrimitiveArrayCritical;
  jint GetStringCritical;
  jint ReleaseStringCritical;
  jint NewWeakGlobalRef;
  jint DeleteWeakGlobalRef;
  jint ExceptionCheck;
  jint NewDirectByteBuffer;
  jint GetDirectBufferAddress;
  jint GetDirectBufferCapacity;
  jint GetObjectRefType;
};
struct bda_c2j_stat_count_jint bda_c2j_count;
struct bda_c2j_stat_count_jint bda_c2j_count_user;

/* proxy for GetVersion*/
static jint JNICALL bda_c2j_proxy_GetVersion(JNIEnv * env)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetVersion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetVersion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetVersion")
    && bda_check_no_exeception(s, "GetVersion")
    && bda_check_no_critical(s, "GetVersion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetVersion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetVersion(env);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for DefineClass*/
static jclass JNICALL bda_c2j_proxy_DefineClass(JNIEnv * env, const char * p1, jobject p2, const jbyte * p3, jsize p4)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.DefineClass++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.DefineClass++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DefineClass")
    && bda_check_no_exeception(s, "DefineClass")
    && bda_check_no_critical(s, "DefineClass")
    && bda_check_non_null(s, p1,  1, "DefineClass")
    && bda_check_non_null(s, p3,  3, "DefineClass")
    && bda_check_ref_dangling(s, p2, 2, "DefineClass")
    && bda_check_assignable_jobject_jclass(s, p2, bda_clazz_classloader, 2, "DefineClass")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DefineClass;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->DefineClass(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "DefineClass")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for FindClass*/
static jclass JNICALL bda_c2j_proxy_FindClass(JNIEnv * env, const char * p1)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.FindClass++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.FindClass++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FindClass")
    && bda_check_no_exeception(s, "FindClass")
    && bda_check_no_critical(s, "FindClass")
    && bda_check_non_null(s, p1,  1, "FindClass")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FindClass;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->FindClass(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "FindClass")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for FromReflectedMethod*/
static jmethodID JNICALL bda_c2j_proxy_FromReflectedMethod(JNIEnv * env, jobject p1)
{
  /* local variables */
  jmethodID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.FromReflectedMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.FromReflectedMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FromReflectedMethod")
    && bda_check_no_exeception(s, "FromReflectedMethod")
    && bda_check_no_critical(s, "FromReflectedMethod")
    && bda_check_non_null(s, p1,  1, "FromReflectedMethod")
    && bda_check_ref_dangling(s, p1, 1, "FromReflectedMethod")
    && bda_check_jobject_reflected_method(s, p1, 1, "FromReflectedMethod")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FromReflectedMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->FromReflectedMethod(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for FromReflectedField*/
static jfieldID JNICALL bda_c2j_proxy_FromReflectedField(JNIEnv * env, jobject p1)
{
  /* local variables */
  jfieldID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.FromReflectedField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.FromReflectedField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FromReflectedField")
    && bda_check_no_exeception(s, "FromReflectedField")
    && bda_check_no_critical(s, "FromReflectedField")
    && bda_check_non_null(s, p1,  1, "FromReflectedField")
    && bda_check_ref_dangling(s, p1, 1, "FromReflectedField")
    && bda_check_instance_jobject_jclass(s, p1, bda_clazz_field, 1, "FromReflectedField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FromReflectedField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->FromReflectedField(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for ToReflectedMethod*/
static jobject JNICALL bda_c2j_proxy_ToReflectedMethod(JNIEnv * env, jclass p1, jmethodID p2, jboolean p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ToReflectedMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ToReflectedMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ToReflectedMethod")
    && bda_check_no_exeception(s, "ToReflectedMethod")
    && bda_check_no_critical(s, "ToReflectedMethod")
    && bda_check_non_null(s, p1,  1, "ToReflectedMethod")
    && bda_check_non_null(s, p2,  2, "ToReflectedMethod")
    && bda_check_ref_dangling(s, p1, 1, "ToReflectedMethod")
    && bda_check_jclass(s, p1, 1, "ToReflectedMethod")
    && bda_check_jmethodid_to_reflected(s, p1, p2, p3, "ToReflectedMethod")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ToReflectedMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ToReflectedMethod(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "ToReflectedMethod")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for GetSuperclass*/
static jclass JNICALL bda_c2j_proxy_GetSuperclass(JNIEnv * env, jclass p1)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetSuperclass++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetSuperclass++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetSuperclass")
    && bda_check_no_exeception(s, "GetSuperclass")
    && bda_check_no_critical(s, "GetSuperclass")
    && bda_check_non_null(s, p1,  1, "GetSuperclass")
    && bda_check_ref_dangling(s, p1, 1, "GetSuperclass")
    && bda_check_jclass(s, p1, 1, "GetSuperclass")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetSuperclass;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetSuperclass(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "GetSuperclass")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for IsAssignableFrom*/
static jboolean JNICALL bda_c2j_proxy_IsAssignableFrom(JNIEnv * env, jclass p1, jclass p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.IsAssignableFrom++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.IsAssignableFrom++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "IsAssignableFrom")
    && bda_check_no_exeception(s, "IsAssignableFrom")
    && bda_check_no_critical(s, "IsAssignableFrom")
    && bda_check_non_null(s, p1,  1, "IsAssignableFrom")
    && bda_check_non_null(s, p2,  2, "IsAssignableFrom")
    && bda_check_ref_dangling(s, p1, 1, "IsAssignableFrom")
    && bda_check_jclass(s, p1, 1, "IsAssignableFrom")
    && bda_check_ref_dangling(s, p2, 2, "IsAssignableFrom")
    && bda_check_jclass(s, p2, 2, "IsAssignableFrom")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_IsAssignableFrom;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->IsAssignableFrom(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for ToReflectedField*/
static jobject JNICALL bda_c2j_proxy_ToReflectedField(JNIEnv * env, jclass p1, jfieldID p2, jboolean p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ToReflectedField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ToReflectedField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ToReflectedField")
    && bda_check_no_exeception(s, "ToReflectedField")
    && bda_check_no_critical(s, "ToReflectedField")
    && bda_check_non_null(s, p1,  1, "ToReflectedField")
    && bda_check_non_null(s, p2,  2, "ToReflectedField")
    && bda_check_ref_dangling(s, p1, 1, "ToReflectedField")
    && bda_check_jclass(s, p1, 1, "ToReflectedField")
    && bda_check_jfieldid_to_reflected_field(s, p1, p2, p3, "ToReflectedField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ToReflectedField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ToReflectedField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "ToReflectedField")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for Throw*/
static jint JNICALL bda_c2j_proxy_Throw(JNIEnv * env, jthrowable p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.Throw++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.Throw++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "Throw")
    && bda_check_no_exeception(s, "Throw")
    && bda_check_no_critical(s, "Throw")
    && bda_check_non_null(s, p1,  1, "Throw")
    && bda_check_ref_dangling(s, p1, 1, "Throw")
    && bda_check_jthrowable(s, p1, 1, "Throw")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_Throw;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->Throw(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for ThrowNew*/
static jint JNICALL bda_c2j_proxy_ThrowNew(JNIEnv * env, jclass p1, const char * p2)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ThrowNew++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ThrowNew++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ThrowNew")
    && bda_check_no_exeception(s, "ThrowNew")
    && bda_check_no_critical(s, "ThrowNew")
    && bda_check_non_null(s, p1,  1, "ThrowNew")
    && bda_check_non_null(s, p2,  2, "ThrowNew")
    && bda_check_ref_dangling(s, p1, 1, "ThrowNew")
    && bda_check_jclass(s, p1, 1, "ThrowNew")
    && bda_check_assignable_jclass_jclass(s, p1, bda_clazz_throwable, 1, "ThrowNew")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ThrowNew;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ThrowNew(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for ExceptionOccurred*/
static jthrowable JNICALL bda_c2j_proxy_ExceptionOccurred(JNIEnv * env)
{
  /* local variables */
  jthrowable result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ExceptionOccurred++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ExceptionOccurred++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionOccurred")
    && bda_check_no_critical(s, "ExceptionOccurred")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionOccurred;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ExceptionOccurred(env);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "ExceptionOccurred")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for ExceptionDescribe*/
static void JNICALL bda_c2j_proxy_ExceptionDescribe(JNIEnv * env)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ExceptionDescribe++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ExceptionDescribe++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionDescribe")
    && bda_check_no_critical(s, "ExceptionDescribe")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionDescribe;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ExceptionDescribe(env);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for ExceptionClear*/
static void JNICALL bda_c2j_proxy_ExceptionClear(JNIEnv * env)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ExceptionClear++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ExceptionClear++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionClear")
    && bda_check_no_critical(s, "ExceptionClear")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionClear;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ExceptionClear(env);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for FatalError*/
static void JNICALL bda_c2j_proxy_FatalError(JNIEnv * env, const char * p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.FatalError++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.FatalError++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FatalError")
    && bda_check_no_exeception(s, "FatalError")
    && bda_check_no_critical(s, "FatalError")
    && bda_check_non_null(s, p1,  1, "FatalError")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FatalError;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->FatalError(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for PushLocalFrame*/
static jint JNICALL bda_c2j_proxy_PushLocalFrame(JNIEnv * env, jint p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.PushLocalFrame++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.PushLocalFrame++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "PushLocalFrame")
    && bda_check_no_exeception(s, "PushLocalFrame")
    && bda_check_no_critical(s, "PushLocalFrame")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_PushLocalFrame;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->PushLocalFrame(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result == 0) {
     bda_local_ref_enter(s, p1, 0);
   }
  }

  return result;
}


/* proxy for PopLocalFrame*/
static jobject JNICALL bda_c2j_proxy_PopLocalFrame(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.PopLocalFrame++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.PopLocalFrame++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "PopLocalFrame")
    && bda_check_no_exeception(s, "PopLocalFrame")
    && bda_check_local_frame_double_free(s)
    && bda_check_no_critical(s, "PopLocalFrame")
    && bda_check_ref_dangling(s, p1, 1, "PopLocalFrame")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_PopLocalFrame;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->PopLocalFrame(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    bda_local_ref_leave(s);
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "PopLocalFrame")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewGlobalRef*/
static jobject JNICALL bda_c2j_proxy_NewGlobalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewGlobalRef++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewGlobalRef++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewGlobalRef")
    && bda_check_no_exeception(s, "NewGlobalRef")
    && bda_check_no_critical(s, "NewGlobalRef")
    && bda_check_non_null(s, p1,  1, "NewGlobalRef")
    && bda_check_ref_dangling(s, p1, 1, "NewGlobalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewGlobalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewGlobalRef(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {
      bda_global_ref_add(result, 0);
    }
  }

  return result;
}


/* proxy for DeleteGlobalRef*/
static void JNICALL bda_c2j_proxy_DeleteGlobalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.DeleteGlobalRef++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.DeleteGlobalRef++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DeleteGlobalRef")
    && bda_check_no_critical(s, "DeleteGlobalRef")
    && bda_check_non_null(s, p1,  1, "DeleteGlobalRef")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "DeleteGlobalRef"))
    && bda_check_jobject_ref_type(s, p1, JNIGlobalRefType, 1, "DeleteGlobalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DeleteGlobalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->DeleteGlobalRef(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   bda_global_ref_delete(p1, 0);
  }

}


/* proxy for DeleteLocalRef*/
static void JNICALL bda_c2j_proxy_DeleteLocalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.DeleteLocalRef++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.DeleteLocalRef++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DeleteLocalRef")
    && bda_check_no_critical(s, "DeleteLocalRef")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "DeleteLocalRef"))
    && bda_check_jobject_ref_type(s, p1, JNILocalRefType, 1, "DeleteLocalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DeleteLocalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->DeleteLocalRef(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (p1 != NULL) {
     bda_local_ref_delete(s, p1);
   }
  }

}


/* proxy for IsSameObject*/
static jboolean JNICALL bda_c2j_proxy_IsSameObject(JNIEnv * env, jobject p1, jobject p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.IsSameObject++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.IsSameObject++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "IsSameObject")
    && bda_check_no_exeception(s, "IsSameObject")
    && bda_check_no_critical(s, "IsSameObject")
    && bda_check_ref_dangling(s, p1, 1, "IsSameObject")
    && bda_check_ref_dangling(s, p2, 2, "IsSameObject")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_IsSameObject;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->IsSameObject(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for NewLocalRef*/
static jobject JNICALL bda_c2j_proxy_NewLocalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewLocalRef++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewLocalRef++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewLocalRef")
    && bda_check_no_exeception(s, "NewLocalRef")
    && bda_check_no_critical(s, "NewLocalRef")
    && bda_check_non_null(s, p1,  1, "NewLocalRef")
    && bda_check_ref_dangling(s, p1, 1, "NewLocalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewLocalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewLocalRef(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewLocalRef")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for EnsureLocalCapacity*/
static jint JNICALL bda_c2j_proxy_EnsureLocalCapacity(JNIEnv * env, jint p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.EnsureLocalCapacity++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.EnsureLocalCapacity++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "EnsureLocalCapacity")
    && bda_check_no_exeception(s, "EnsureLocalCapacity")
    && bda_check_no_critical(s, "EnsureLocalCapacity")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_EnsureLocalCapacity;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->EnsureLocalCapacity(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for AllocObject*/
static jobject JNICALL bda_c2j_proxy_AllocObject(JNIEnv * env, jclass p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.AllocObject++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.AllocObject++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "AllocObject")
    && bda_check_no_exeception(s, "AllocObject")
    && bda_check_no_critical(s, "AllocObject")
    && bda_check_non_null(s, p1,  1, "AllocObject")
    && bda_check_ref_dangling(s, p1, 1, "AllocObject")
    && bda_check_jclass(s, p1, 1, "AllocObject")
    && bda_check_jclass_scalar_allocatable(s, p1, 1, "AllocObject")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_AllocObject;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->AllocObject(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "AllocObject")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewObject*/
static jobject JNICALL bda_c2j_proxy_NewObject(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewObject++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewObject++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "NewObject")
    && bda_check_no_exeception(s, "NewObject")
    && bda_check_no_critical(s, "NewObject")
    && bda_check_non_null(s, p1,  1, "NewObject")
    && bda_check_non_null(s, p2,  2, "NewObject")
    && bda_check_ref_dangling(s, p1, 1, "NewObject")
    && bda_check_jclass(s, p1, 1, "NewObject")
    && bda_check_jmethodid_new_object(s, p1, p2, awrap, "NewObject")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObject;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->NewObjectV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewObject")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewObjectV*/
static jobject JNICALL bda_c2j_proxy_NewObjectV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewObjectV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewObjectV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
    awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "NewObjectV")
    && bda_check_no_exeception(s, "NewObjectV")
    && bda_check_no_critical(s, "NewObjectV")
    && bda_check_non_null(s, p1,  1, "NewObjectV")
    && bda_check_non_null(s, p2,  2, "NewObjectV")
    && bda_check_ref_dangling(s, p1, 1, "NewObjectV")
    && bda_check_jclass(s, p1, 1, "NewObjectV")
    && bda_check_jmethodid_new_object(s, p1, p2, awrap, "NewObjectV")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObjectV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewObjectV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewObjectV")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewObjectA*/
static jobject JNICALL bda_c2j_proxy_NewObjectA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewObjectA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewObjectA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "NewObjectA")
    && bda_check_no_exeception(s, "NewObjectA")
    && bda_check_no_critical(s, "NewObjectA")
    && bda_check_non_null(s, p1,  1, "NewObjectA")
    && bda_check_non_null(s, p2,  2, "NewObjectA")
    && bda_check_ref_dangling(s, p1, 1, "NewObjectA")
    && bda_check_jclass(s, p1, 1, "NewObjectA")
    && bda_check_jmethodid_new_object(s, p1, p2, awrap, "NewObjectA")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObjectA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewObjectA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewObjectA")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for GetObjectClass*/
static jclass JNICALL bda_c2j_proxy_GetObjectClass(JNIEnv * env, jobject p1)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetObjectClass++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetObjectClass++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectClass")
    && bda_check_no_exeception(s, "GetObjectClass")
    && bda_check_no_critical(s, "GetObjectClass")
    && bda_check_non_null(s, p1,  1, "GetObjectClass")
    && bda_check_ref_dangling(s, p1, 1, "GetObjectClass")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectClass;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectClass(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "GetObjectClass")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for IsInstanceOf*/
static jboolean JNICALL bda_c2j_proxy_IsInstanceOf(JNIEnv * env, jobject p1, jclass p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.IsInstanceOf++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.IsInstanceOf++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "IsInstanceOf")
    && bda_check_no_exeception(s, "IsInstanceOf")
    && bda_check_no_critical(s, "IsInstanceOf")
    && bda_check_non_null(s, p1,  1, "IsInstanceOf")
    && bda_check_non_null(s, p2,  2, "IsInstanceOf")
    && bda_check_ref_dangling(s, p1, 1, "IsInstanceOf")
    && bda_check_ref_dangling(s, p2, 2, "IsInstanceOf")
    && bda_check_jclass(s, p2, 2, "IsInstanceOf")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_IsInstanceOf;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->IsInstanceOf(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetMethodID*/
static jmethodID JNICALL bda_c2j_proxy_GetMethodID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jmethodID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetMethodID++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetMethodID++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetMethodID")
    && bda_check_no_exeception(s, "GetMethodID")
    && bda_check_no_critical(s, "GetMethodID")
    && bda_check_non_null(s, p1,  1, "GetMethodID")
    && bda_check_non_null(s, p2,  2, "GetMethodID")
    && bda_check_non_null(s, p3,  3, "GetMethodID")
    && bda_check_ref_dangling(s, p1, 1, "GetMethodID")
    && bda_check_jclass(s, p1, 1, "GetMethodID")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetMethodID;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetMethodID(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jmethodid_append( result, 0, p1, p2, p3);
   }
  }

  return result;
}


/* proxy for CallObjectMethod*/
static jobject JNICALL bda_c2j_proxy_CallObjectMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallObjectMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallObjectMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallObjectMethod")
    && bda_check_no_exeception(s, "CallObjectMethod")
    && bda_check_no_critical(s, "CallObjectMethod")
    && bda_check_non_null(s, p1,  1, "CallObjectMethod")
    && bda_check_non_null(s, p2,  2, "CallObjectMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallObjectMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallObjectMethod", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallObjectMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallObjectMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallObjectMethod")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for CallObjectMethodV*/
static jobject JNICALL bda_c2j_proxy_CallObjectMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallObjectMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallObjectMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallObjectMethodV")
    && bda_check_no_exeception(s, "CallObjectMethodV")
    && bda_check_no_critical(s, "CallObjectMethodV")
    && bda_check_non_null(s, p1,  1, "CallObjectMethodV")
    && bda_check_non_null(s, p2,  2, "CallObjectMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallObjectMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallObjectMethodV", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallObjectMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallObjectMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallObjectMethodV")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for CallObjectMethodA*/
static jobject JNICALL bda_c2j_proxy_CallObjectMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallObjectMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallObjectMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallObjectMethodA")
    && bda_check_no_exeception(s, "CallObjectMethodA")
    && bda_check_no_critical(s, "CallObjectMethodA")
    && bda_check_non_null(s, p1,  1, "CallObjectMethodA")
    && bda_check_non_null(s, p2,  2, "CallObjectMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallObjectMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallObjectMethodA", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallObjectMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallObjectMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallObjectMethodA")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for CallBooleanMethod*/
static jboolean JNICALL bda_c2j_proxy_CallBooleanMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallBooleanMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallBooleanMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallBooleanMethod")
    && bda_check_no_exeception(s, "CallBooleanMethod")
    && bda_check_no_critical(s, "CallBooleanMethod")
    && bda_check_non_null(s, p1,  1, "CallBooleanMethod")
    && bda_check_non_null(s, p2,  2, "CallBooleanMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallBooleanMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallBooleanMethod", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallBooleanMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallBooleanMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallBooleanMethodV*/
static jboolean JNICALL bda_c2j_proxy_CallBooleanMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallBooleanMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallBooleanMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallBooleanMethodV")
    && bda_check_no_exeception(s, "CallBooleanMethodV")
    && bda_check_no_critical(s, "CallBooleanMethodV")
    && bda_check_non_null(s, p1,  1, "CallBooleanMethodV")
    && bda_check_non_null(s, p2,  2, "CallBooleanMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallBooleanMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallBooleanMethodV", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallBooleanMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallBooleanMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallBooleanMethodA*/
static jboolean JNICALL bda_c2j_proxy_CallBooleanMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallBooleanMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallBooleanMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallBooleanMethodA")
    && bda_check_no_exeception(s, "CallBooleanMethodA")
    && bda_check_no_critical(s, "CallBooleanMethodA")
    && bda_check_non_null(s, p1,  1, "CallBooleanMethodA")
    && bda_check_non_null(s, p2,  2, "CallBooleanMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallBooleanMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallBooleanMethodA", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallBooleanMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallBooleanMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallByteMethod*/
static jbyte JNICALL bda_c2j_proxy_CallByteMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallByteMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallByteMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallByteMethod")
    && bda_check_no_exeception(s, "CallByteMethod")
    && bda_check_no_critical(s, "CallByteMethod")
    && bda_check_non_null(s, p1,  1, "CallByteMethod")
    && bda_check_non_null(s, p2,  2, "CallByteMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallByteMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallByteMethod", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallByteMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallByteMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallByteMethodV*/
static jbyte JNICALL bda_c2j_proxy_CallByteMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallByteMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallByteMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallByteMethodV")
    && bda_check_no_exeception(s, "CallByteMethodV")
    && bda_check_no_critical(s, "CallByteMethodV")
    && bda_check_non_null(s, p1,  1, "CallByteMethodV")
    && bda_check_non_null(s, p2,  2, "CallByteMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallByteMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallByteMethodV", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallByteMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallByteMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallByteMethodA*/
static jbyte JNICALL bda_c2j_proxy_CallByteMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallByteMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallByteMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallByteMethodA")
    && bda_check_no_exeception(s, "CallByteMethodA")
    && bda_check_no_critical(s, "CallByteMethodA")
    && bda_check_non_null(s, p1,  1, "CallByteMethodA")
    && bda_check_non_null(s, p2,  2, "CallByteMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallByteMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallByteMethodA", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallByteMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallByteMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallCharMethod*/
static jchar JNICALL bda_c2j_proxy_CallCharMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallCharMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallCharMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallCharMethod")
    && bda_check_no_exeception(s, "CallCharMethod")
    && bda_check_no_critical(s, "CallCharMethod")
    && bda_check_non_null(s, p1,  1, "CallCharMethod")
    && bda_check_non_null(s, p2,  2, "CallCharMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallCharMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallCharMethod", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallCharMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallCharMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallCharMethodV*/
static jchar JNICALL bda_c2j_proxy_CallCharMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallCharMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallCharMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallCharMethodV")
    && bda_check_no_exeception(s, "CallCharMethodV")
    && bda_check_no_critical(s, "CallCharMethodV")
    && bda_check_non_null(s, p1,  1, "CallCharMethodV")
    && bda_check_non_null(s, p2,  2, "CallCharMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallCharMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallCharMethodV", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallCharMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallCharMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallCharMethodA*/
static jchar JNICALL bda_c2j_proxy_CallCharMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallCharMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallCharMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallCharMethodA")
    && bda_check_no_exeception(s, "CallCharMethodA")
    && bda_check_no_critical(s, "CallCharMethodA")
    && bda_check_non_null(s, p1,  1, "CallCharMethodA")
    && bda_check_non_null(s, p2,  2, "CallCharMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallCharMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallCharMethodA", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallCharMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallCharMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallShortMethod*/
static jshort JNICALL bda_c2j_proxy_CallShortMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallShortMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallShortMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallShortMethod")
    && bda_check_no_exeception(s, "CallShortMethod")
    && bda_check_no_critical(s, "CallShortMethod")
    && bda_check_non_null(s, p1,  1, "CallShortMethod")
    && bda_check_non_null(s, p2,  2, "CallShortMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallShortMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallShortMethod", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallShortMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallShortMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallShortMethodV*/
static jshort JNICALL bda_c2j_proxy_CallShortMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallShortMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallShortMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallShortMethodV")
    && bda_check_no_exeception(s, "CallShortMethodV")
    && bda_check_no_critical(s, "CallShortMethodV")
    && bda_check_non_null(s, p1,  1, "CallShortMethodV")
    && bda_check_non_null(s, p2,  2, "CallShortMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallShortMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallShortMethodV", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallShortMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallShortMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallShortMethodA*/
static jshort JNICALL bda_c2j_proxy_CallShortMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallShortMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallShortMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallShortMethodA")
    && bda_check_no_exeception(s, "CallShortMethodA")
    && bda_check_no_critical(s, "CallShortMethodA")
    && bda_check_non_null(s, p1,  1, "CallShortMethodA")
    && bda_check_non_null(s, p2,  2, "CallShortMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallShortMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallShortMethodA", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallShortMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallShortMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallIntMethod*/
static jint JNICALL bda_c2j_proxy_CallIntMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallIntMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallIntMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallIntMethod")
    && bda_check_no_exeception(s, "CallIntMethod")
    && bda_check_no_critical(s, "CallIntMethod")
    && bda_check_non_null(s, p1,  1, "CallIntMethod")
    && bda_check_non_null(s, p2,  2, "CallIntMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallIntMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallIntMethod", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallIntMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallIntMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallIntMethodV*/
static jint JNICALL bda_c2j_proxy_CallIntMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallIntMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallIntMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallIntMethodV")
    && bda_check_no_exeception(s, "CallIntMethodV")
    && bda_check_no_critical(s, "CallIntMethodV")
    && bda_check_non_null(s, p1,  1, "CallIntMethodV")
    && bda_check_non_null(s, p2,  2, "CallIntMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallIntMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallIntMethodV", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallIntMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallIntMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallIntMethodA*/
static jint JNICALL bda_c2j_proxy_CallIntMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallIntMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallIntMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallIntMethodA")
    && bda_check_no_exeception(s, "CallIntMethodA")
    && bda_check_no_critical(s, "CallIntMethodA")
    && bda_check_non_null(s, p1,  1, "CallIntMethodA")
    && bda_check_non_null(s, p2,  2, "CallIntMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallIntMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallIntMethodA", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallIntMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallIntMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallLongMethod*/
static jlong JNICALL bda_c2j_proxy_CallLongMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallLongMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallLongMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallLongMethod")
    && bda_check_no_exeception(s, "CallLongMethod")
    && bda_check_no_critical(s, "CallLongMethod")
    && bda_check_non_null(s, p1,  1, "CallLongMethod")
    && bda_check_non_null(s, p2,  2, "CallLongMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallLongMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallLongMethod", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallLongMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallLongMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallLongMethodV*/
static jlong JNICALL bda_c2j_proxy_CallLongMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallLongMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallLongMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallLongMethodV")
    && bda_check_no_exeception(s, "CallLongMethodV")
    && bda_check_no_critical(s, "CallLongMethodV")
    && bda_check_non_null(s, p1,  1, "CallLongMethodV")
    && bda_check_non_null(s, p2,  2, "CallLongMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallLongMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallLongMethodV", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallLongMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallLongMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallLongMethodA*/
static jlong JNICALL bda_c2j_proxy_CallLongMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallLongMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallLongMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallLongMethodA")
    && bda_check_no_exeception(s, "CallLongMethodA")
    && bda_check_no_critical(s, "CallLongMethodA")
    && bda_check_non_null(s, p1,  1, "CallLongMethodA")
    && bda_check_non_null(s, p2,  2, "CallLongMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallLongMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallLongMethodA", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallLongMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallLongMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallFloatMethod*/
static jfloat JNICALL bda_c2j_proxy_CallFloatMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallFloatMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallFloatMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallFloatMethod")
    && bda_check_no_exeception(s, "CallFloatMethod")
    && bda_check_no_critical(s, "CallFloatMethod")
    && bda_check_non_null(s, p1,  1, "CallFloatMethod")
    && bda_check_non_null(s, p2,  2, "CallFloatMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallFloatMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallFloatMethod", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallFloatMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallFloatMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallFloatMethodV*/
static jfloat JNICALL bda_c2j_proxy_CallFloatMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallFloatMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallFloatMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallFloatMethodV")
    && bda_check_no_exeception(s, "CallFloatMethodV")
    && bda_check_no_critical(s, "CallFloatMethodV")
    && bda_check_non_null(s, p1,  1, "CallFloatMethodV")
    && bda_check_non_null(s, p2,  2, "CallFloatMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallFloatMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallFloatMethodV", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallFloatMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallFloatMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallFloatMethodA*/
static jfloat JNICALL bda_c2j_proxy_CallFloatMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallFloatMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallFloatMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallFloatMethodA")
    && bda_check_no_exeception(s, "CallFloatMethodA")
    && bda_check_no_critical(s, "CallFloatMethodA")
    && bda_check_non_null(s, p1,  1, "CallFloatMethodA")
    && bda_check_non_null(s, p2,  2, "CallFloatMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallFloatMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallFloatMethodA", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallFloatMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallFloatMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallDoubleMethod*/
static jdouble JNICALL bda_c2j_proxy_CallDoubleMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallDoubleMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallDoubleMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallDoubleMethod")
    && bda_check_no_exeception(s, "CallDoubleMethod")
    && bda_check_no_critical(s, "CallDoubleMethod")
    && bda_check_non_null(s, p1,  1, "CallDoubleMethod")
    && bda_check_non_null(s, p2,  2, "CallDoubleMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallDoubleMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallDoubleMethod", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallDoubleMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallDoubleMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallDoubleMethodV*/
static jdouble JNICALL bda_c2j_proxy_CallDoubleMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallDoubleMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallDoubleMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallDoubleMethodV")
    && bda_check_no_exeception(s, "CallDoubleMethodV")
    && bda_check_no_critical(s, "CallDoubleMethodV")
    && bda_check_non_null(s, p1,  1, "CallDoubleMethodV")
    && bda_check_non_null(s, p2,  2, "CallDoubleMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallDoubleMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallDoubleMethodV", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallDoubleMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallDoubleMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallDoubleMethodA*/
static jdouble JNICALL bda_c2j_proxy_CallDoubleMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallDoubleMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallDoubleMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallDoubleMethodA")
    && bda_check_no_exeception(s, "CallDoubleMethodA")
    && bda_check_no_critical(s, "CallDoubleMethodA")
    && bda_check_non_null(s, p1,  1, "CallDoubleMethodA")
    && bda_check_non_null(s, p2,  2, "CallDoubleMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallDoubleMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallDoubleMethodA", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallDoubleMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallDoubleMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallVoidMethod*/
static void JNICALL bda_c2j_proxy_CallVoidMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallVoidMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallVoidMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallVoidMethod")
    && bda_check_no_exeception(s, "CallVoidMethod")
    && bda_check_no_critical(s, "CallVoidMethod")
    && bda_check_non_null(s, p1,  1, "CallVoidMethod")
    && bda_check_non_null(s, p2,  2, "CallVoidMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallVoidMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallVoidMethod", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallVoidMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  bda_orig_jni_funcs->CallVoidMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for CallVoidMethodV*/
static void JNICALL bda_c2j_proxy_CallVoidMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallVoidMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallVoidMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallVoidMethodV")
    && bda_check_no_exeception(s, "CallVoidMethodV")
    && bda_check_no_critical(s, "CallVoidMethodV")
    && bda_check_non_null(s, p1,  1, "CallVoidMethodV")
    && bda_check_non_null(s, p2,  2, "CallVoidMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallVoidMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallVoidMethodV", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallVoidMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallVoidMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for CallVoidMethodA*/
static void JNICALL bda_c2j_proxy_CallVoidMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallVoidMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallVoidMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallVoidMethodA")
    && bda_check_no_exeception(s, "CallVoidMethodA")
    && bda_check_no_critical(s, "CallVoidMethodA")
    && bda_check_non_null(s, p1,  1, "CallVoidMethodA")
    && bda_check_non_null(s, p2,  2, "CallVoidMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallVoidMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallVoidMethodA", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallVoidMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallVoidMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for CallNonvirtualObjectMethod*/
static jobject JNICALL bda_c2j_proxy_CallNonvirtualObjectMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualObjectMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualObjectMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualObjectMethod")
    && bda_check_no_exeception(s, "CallNonvirtualObjectMethod")
    && bda_check_no_critical(s, "CallNonvirtualObjectMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualObjectMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualObjectMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualObjectMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualObjectMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualObjectMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualObjectMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualObjectMethod", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualObjectMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualObjectMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallNonvirtualObjectMethod")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for CallNonvirtualObjectMethodV*/
static jobject JNICALL bda_c2j_proxy_CallNonvirtualObjectMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualObjectMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualObjectMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualObjectMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualObjectMethodV")
    && bda_check_no_critical(s, "CallNonvirtualObjectMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualObjectMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualObjectMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualObjectMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualObjectMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualObjectMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualObjectMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualObjectMethodV", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualObjectMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualObjectMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallNonvirtualObjectMethodV")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for CallNonvirtualObjectMethodA*/
static jobject JNICALL bda_c2j_proxy_CallNonvirtualObjectMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualObjectMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualObjectMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualObjectMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualObjectMethodA")
    && bda_check_no_critical(s, "CallNonvirtualObjectMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualObjectMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualObjectMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualObjectMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualObjectMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualObjectMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualObjectMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualObjectMethodA", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualObjectMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualObjectMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallNonvirtualObjectMethodA")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for CallNonvirtualBooleanMethod*/
static jboolean JNICALL bda_c2j_proxy_CallNonvirtualBooleanMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualBooleanMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualBooleanMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualBooleanMethod")
    && bda_check_no_exeception(s, "CallNonvirtualBooleanMethod")
    && bda_check_no_critical(s, "CallNonvirtualBooleanMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualBooleanMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualBooleanMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualBooleanMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualBooleanMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualBooleanMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualBooleanMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualBooleanMethod", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualBooleanMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualBooleanMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualBooleanMethodV*/
static jboolean JNICALL bda_c2j_proxy_CallNonvirtualBooleanMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualBooleanMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualBooleanMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualBooleanMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualBooleanMethodV")
    && bda_check_no_critical(s, "CallNonvirtualBooleanMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualBooleanMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualBooleanMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualBooleanMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualBooleanMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualBooleanMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualBooleanMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualBooleanMethodV", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualBooleanMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualBooleanMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualBooleanMethodA*/
static jboolean JNICALL bda_c2j_proxy_CallNonvirtualBooleanMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualBooleanMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualBooleanMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualBooleanMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualBooleanMethodA")
    && bda_check_no_critical(s, "CallNonvirtualBooleanMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualBooleanMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualBooleanMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualBooleanMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualBooleanMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualBooleanMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualBooleanMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualBooleanMethodA", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualBooleanMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualBooleanMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualByteMethod*/
static jbyte JNICALL bda_c2j_proxy_CallNonvirtualByteMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualByteMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualByteMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualByteMethod")
    && bda_check_no_exeception(s, "CallNonvirtualByteMethod")
    && bda_check_no_critical(s, "CallNonvirtualByteMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualByteMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualByteMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualByteMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualByteMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualByteMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualByteMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualByteMethod", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualByteMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualByteMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualByteMethodV*/
static jbyte JNICALL bda_c2j_proxy_CallNonvirtualByteMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualByteMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualByteMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualByteMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualByteMethodV")
    && bda_check_no_critical(s, "CallNonvirtualByteMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualByteMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualByteMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualByteMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualByteMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualByteMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualByteMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualByteMethodV", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualByteMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualByteMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualByteMethodA*/
static jbyte JNICALL bda_c2j_proxy_CallNonvirtualByteMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualByteMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualByteMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualByteMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualByteMethodA")
    && bda_check_no_critical(s, "CallNonvirtualByteMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualByteMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualByteMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualByteMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualByteMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualByteMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualByteMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualByteMethodA", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualByteMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualByteMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualCharMethod*/
static jchar JNICALL bda_c2j_proxy_CallNonvirtualCharMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualCharMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualCharMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualCharMethod")
    && bda_check_no_exeception(s, "CallNonvirtualCharMethod")
    && bda_check_no_critical(s, "CallNonvirtualCharMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualCharMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualCharMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualCharMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualCharMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualCharMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualCharMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualCharMethod", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualCharMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualCharMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualCharMethodV*/
static jchar JNICALL bda_c2j_proxy_CallNonvirtualCharMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualCharMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualCharMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualCharMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualCharMethodV")
    && bda_check_no_critical(s, "CallNonvirtualCharMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualCharMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualCharMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualCharMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualCharMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualCharMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualCharMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualCharMethodV", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualCharMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualCharMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualCharMethodA*/
static jchar JNICALL bda_c2j_proxy_CallNonvirtualCharMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualCharMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualCharMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualCharMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualCharMethodA")
    && bda_check_no_critical(s, "CallNonvirtualCharMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualCharMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualCharMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualCharMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualCharMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualCharMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualCharMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualCharMethodA", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualCharMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualCharMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualShortMethod*/
static jshort JNICALL bda_c2j_proxy_CallNonvirtualShortMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualShortMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualShortMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualShortMethod")
    && bda_check_no_exeception(s, "CallNonvirtualShortMethod")
    && bda_check_no_critical(s, "CallNonvirtualShortMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualShortMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualShortMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualShortMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualShortMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualShortMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualShortMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualShortMethod", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualShortMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualShortMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualShortMethodV*/
static jshort JNICALL bda_c2j_proxy_CallNonvirtualShortMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualShortMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualShortMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualShortMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualShortMethodV")
    && bda_check_no_critical(s, "CallNonvirtualShortMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualShortMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualShortMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualShortMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualShortMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualShortMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualShortMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualShortMethodV", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualShortMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualShortMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualShortMethodA*/
static jshort JNICALL bda_c2j_proxy_CallNonvirtualShortMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualShortMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualShortMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualShortMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualShortMethodA")
    && bda_check_no_critical(s, "CallNonvirtualShortMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualShortMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualShortMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualShortMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualShortMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualShortMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualShortMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualShortMethodA", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualShortMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualShortMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualIntMethod*/
static jint JNICALL bda_c2j_proxy_CallNonvirtualIntMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualIntMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualIntMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualIntMethod")
    && bda_check_no_exeception(s, "CallNonvirtualIntMethod")
    && bda_check_no_critical(s, "CallNonvirtualIntMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualIntMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualIntMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualIntMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualIntMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualIntMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualIntMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualIntMethod", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualIntMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualIntMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualIntMethodV*/
static jint JNICALL bda_c2j_proxy_CallNonvirtualIntMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualIntMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualIntMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualIntMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualIntMethodV")
    && bda_check_no_critical(s, "CallNonvirtualIntMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualIntMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualIntMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualIntMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualIntMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualIntMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualIntMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualIntMethodV", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualIntMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualIntMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualIntMethodA*/
static jint JNICALL bda_c2j_proxy_CallNonvirtualIntMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualIntMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualIntMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualIntMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualIntMethodA")
    && bda_check_no_critical(s, "CallNonvirtualIntMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualIntMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualIntMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualIntMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualIntMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualIntMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualIntMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualIntMethodA", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualIntMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualIntMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualLongMethod*/
static jlong JNICALL bda_c2j_proxy_CallNonvirtualLongMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualLongMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualLongMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualLongMethod")
    && bda_check_no_exeception(s, "CallNonvirtualLongMethod")
    && bda_check_no_critical(s, "CallNonvirtualLongMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualLongMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualLongMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualLongMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualLongMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualLongMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualLongMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualLongMethod", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualLongMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualLongMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualLongMethodV*/
static jlong JNICALL bda_c2j_proxy_CallNonvirtualLongMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualLongMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualLongMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualLongMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualLongMethodV")
    && bda_check_no_critical(s, "CallNonvirtualLongMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualLongMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualLongMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualLongMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualLongMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualLongMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualLongMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualLongMethodV", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualLongMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualLongMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualLongMethodA*/
static jlong JNICALL bda_c2j_proxy_CallNonvirtualLongMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualLongMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualLongMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualLongMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualLongMethodA")
    && bda_check_no_critical(s, "CallNonvirtualLongMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualLongMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualLongMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualLongMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualLongMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualLongMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualLongMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualLongMethodA", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualLongMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualLongMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualFloatMethod*/
static jfloat JNICALL bda_c2j_proxy_CallNonvirtualFloatMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualFloatMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualFloatMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualFloatMethod")
    && bda_check_no_exeception(s, "CallNonvirtualFloatMethod")
    && bda_check_no_critical(s, "CallNonvirtualFloatMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualFloatMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualFloatMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualFloatMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualFloatMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualFloatMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualFloatMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualFloatMethod", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualFloatMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualFloatMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualFloatMethodV*/
static jfloat JNICALL bda_c2j_proxy_CallNonvirtualFloatMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualFloatMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualFloatMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualFloatMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualFloatMethodV")
    && bda_check_no_critical(s, "CallNonvirtualFloatMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualFloatMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualFloatMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualFloatMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualFloatMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualFloatMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualFloatMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualFloatMethodV", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualFloatMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualFloatMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualFloatMethodA*/
static jfloat JNICALL bda_c2j_proxy_CallNonvirtualFloatMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualFloatMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualFloatMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualFloatMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualFloatMethodA")
    && bda_check_no_critical(s, "CallNonvirtualFloatMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualFloatMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualFloatMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualFloatMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualFloatMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualFloatMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualFloatMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualFloatMethodA", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualFloatMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualFloatMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualDoubleMethod*/
static jdouble JNICALL bda_c2j_proxy_CallNonvirtualDoubleMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualDoubleMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualDoubleMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualDoubleMethod")
    && bda_check_no_exeception(s, "CallNonvirtualDoubleMethod")
    && bda_check_no_critical(s, "CallNonvirtualDoubleMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualDoubleMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualDoubleMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualDoubleMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualDoubleMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualDoubleMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualDoubleMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualDoubleMethod", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualDoubleMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualDoubleMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualDoubleMethodV*/
static jdouble JNICALL bda_c2j_proxy_CallNonvirtualDoubleMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualDoubleMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualDoubleMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualDoubleMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualDoubleMethodV")
    && bda_check_no_critical(s, "CallNonvirtualDoubleMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualDoubleMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualDoubleMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualDoubleMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualDoubleMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualDoubleMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualDoubleMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualDoubleMethodV", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualDoubleMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualDoubleMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualDoubleMethodA*/
static jdouble JNICALL bda_c2j_proxy_CallNonvirtualDoubleMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualDoubleMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualDoubleMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualDoubleMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualDoubleMethodA")
    && bda_check_no_critical(s, "CallNonvirtualDoubleMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualDoubleMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualDoubleMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualDoubleMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualDoubleMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualDoubleMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualDoubleMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualDoubleMethodA", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualDoubleMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualDoubleMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallNonvirtualVoidMethod*/
static void JNICALL bda_c2j_proxy_CallNonvirtualVoidMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualVoidMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualVoidMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualVoidMethod")
    && bda_check_no_exeception(s, "CallNonvirtualVoidMethod")
    && bda_check_no_critical(s, "CallNonvirtualVoidMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualVoidMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualVoidMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualVoidMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualVoidMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualVoidMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualVoidMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualVoidMethod", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualVoidMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  bda_orig_jni_funcs->CallNonvirtualVoidMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for CallNonvirtualVoidMethodV*/
static void JNICALL bda_c2j_proxy_CallNonvirtualVoidMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualVoidMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualVoidMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualVoidMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualVoidMethodV")
    && bda_check_no_critical(s, "CallNonvirtualVoidMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualVoidMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualVoidMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualVoidMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualVoidMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualVoidMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualVoidMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualVoidMethodV", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualVoidMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallNonvirtualVoidMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for CallNonvirtualVoidMethodA*/
static void JNICALL bda_c2j_proxy_CallNonvirtualVoidMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallNonvirtualVoidMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallNonvirtualVoidMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualVoidMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualVoidMethodA")
    && bda_check_no_critical(s, "CallNonvirtualVoidMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualVoidMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualVoidMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualVoidMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualVoidMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualVoidMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualVoidMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualVoidMethodA", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualVoidMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallNonvirtualVoidMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetFieldID*/
static jfieldID JNICALL bda_c2j_proxy_GetFieldID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jfieldID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetFieldID++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetFieldID++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFieldID")
    && bda_check_no_exeception(s, "GetFieldID")
    && bda_check_no_critical(s, "GetFieldID")
    && bda_check_non_null(s, p1,  1, "GetFieldID")
    && bda_check_non_null(s, p2,  2, "GetFieldID")
    && bda_check_non_null(s, p3,  3, "GetFieldID")
    && bda_check_ref_dangling(s, p1, 1, "GetFieldID")
    && bda_check_jclass(s, p1, 1, "GetFieldID")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFieldID;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetFieldID(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jfieldid_append(s, result, p1, 0, p2, p3);
   }
  }

  return result;
}


/* proxy for GetObjectField*/
static jobject JNICALL bda_c2j_proxy_GetObjectField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetObjectField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetObjectField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectField")
    && bda_check_no_exeception(s, "GetObjectField")
    && bda_check_no_critical(s, "GetObjectField")
    && bda_check_non_null(s, p1,  1, "GetObjectField")
    && bda_check_non_null(s, p2,  2, "GetObjectField")
    && bda_check_ref_dangling(s, p1, 1, "GetObjectField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'O', "GetObjectField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "GetObjectField")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for GetBooleanField*/
static jboolean JNICALL bda_c2j_proxy_GetBooleanField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetBooleanField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetBooleanField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetBooleanField")
    && bda_check_no_exeception(s, "GetBooleanField")
    && bda_check_no_critical(s, "GetBooleanField")
    && bda_check_non_null(s, p1,  1, "GetBooleanField")
    && bda_check_non_null(s, p2,  2, "GetBooleanField")
    && bda_check_ref_dangling(s, p1, 1, "GetBooleanField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'Z', "GetBooleanField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetBooleanField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetBooleanField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetByteField*/
static jbyte JNICALL bda_c2j_proxy_GetByteField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetByteField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetByteField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetByteField")
    && bda_check_no_exeception(s, "GetByteField")
    && bda_check_no_critical(s, "GetByteField")
    && bda_check_non_null(s, p1,  1, "GetByteField")
    && bda_check_non_null(s, p2,  2, "GetByteField")
    && bda_check_ref_dangling(s, p1, 1, "GetByteField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'B', "GetByteField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetByteField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetByteField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetCharField*/
static jchar JNICALL bda_c2j_proxy_GetCharField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetCharField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetCharField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetCharField")
    && bda_check_no_exeception(s, "GetCharField")
    && bda_check_no_critical(s, "GetCharField")
    && bda_check_non_null(s, p1,  1, "GetCharField")
    && bda_check_non_null(s, p2,  2, "GetCharField")
    && bda_check_ref_dangling(s, p1, 1, "GetCharField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'C', "GetCharField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetCharField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetCharField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetShortField*/
static jshort JNICALL bda_c2j_proxy_GetShortField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetShortField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetShortField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetShortField")
    && bda_check_no_exeception(s, "GetShortField")
    && bda_check_no_critical(s, "GetShortField")
    && bda_check_non_null(s, p1,  1, "GetShortField")
    && bda_check_non_null(s, p2,  2, "GetShortField")
    && bda_check_ref_dangling(s, p1, 1, "GetShortField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'S', "GetShortField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetShortField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetShortField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetIntField*/
static jint JNICALL bda_c2j_proxy_GetIntField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetIntField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetIntField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetIntField")
    && bda_check_no_exeception(s, "GetIntField")
    && bda_check_no_critical(s, "GetIntField")
    && bda_check_non_null(s, p1,  1, "GetIntField")
    && bda_check_non_null(s, p2,  2, "GetIntField")
    && bda_check_ref_dangling(s, p1, 1, "GetIntField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'I', "GetIntField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetIntField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetIntField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetLongField*/
static jlong JNICALL bda_c2j_proxy_GetLongField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetLongField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetLongField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetLongField")
    && bda_check_no_exeception(s, "GetLongField")
    && bda_check_no_critical(s, "GetLongField")
    && bda_check_non_null(s, p1,  1, "GetLongField")
    && bda_check_non_null(s, p2,  2, "GetLongField")
    && bda_check_ref_dangling(s, p1, 1, "GetLongField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'J', "GetLongField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetLongField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetLongField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetFloatField*/
static jfloat JNICALL bda_c2j_proxy_GetFloatField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetFloatField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetFloatField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFloatField")
    && bda_check_no_exeception(s, "GetFloatField")
    && bda_check_no_critical(s, "GetFloatField")
    && bda_check_non_null(s, p1,  1, "GetFloatField")
    && bda_check_non_null(s, p2,  2, "GetFloatField")
    && bda_check_ref_dangling(s, p1, 1, "GetFloatField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'F', "GetFloatField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFloatField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetFloatField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetDoubleField*/
static jdouble JNICALL bda_c2j_proxy_GetDoubleField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetDoubleField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetDoubleField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDoubleField")
    && bda_check_no_exeception(s, "GetDoubleField")
    && bda_check_no_critical(s, "GetDoubleField")
    && bda_check_non_null(s, p1,  1, "GetDoubleField")
    && bda_check_non_null(s, p2,  2, "GetDoubleField")
    && bda_check_ref_dangling(s, p1, 1, "GetDoubleField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'D', "GetDoubleField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDoubleField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDoubleField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for SetObjectField*/
static void JNICALL bda_c2j_proxy_SetObjectField(JNIEnv * env, jobject p1, jfieldID p2, jobject p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetObjectField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetObjectField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.l = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetObjectField")
    && bda_check_no_exeception(s, "SetObjectField")
    && bda_check_no_critical(s, "SetObjectField")
    && bda_check_non_null(s, p1,  1, "SetObjectField")
    && bda_check_non_null(s, p2,  2, "SetObjectField")
    && bda_check_ref_dangling(s, p1, 1, "SetObjectField")
    && bda_check_ref_dangling(s, p3, 3, "SetObjectField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'O', "SetObjectField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetObjectField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetObjectField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetObjectField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetBooleanField*/
static void JNICALL bda_c2j_proxy_SetBooleanField(JNIEnv * env, jobject p1, jfieldID p2, jboolean p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetBooleanField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetBooleanField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.z = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetBooleanField")
    && bda_check_no_exeception(s, "SetBooleanField")
    && bda_check_no_critical(s, "SetBooleanField")
    && bda_check_non_null(s, p1,  1, "SetBooleanField")
    && bda_check_non_null(s, p2,  2, "SetBooleanField")
    && bda_check_ref_dangling(s, p1, 1, "SetBooleanField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'Z', "SetBooleanField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetBooleanField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetBooleanField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetBooleanField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetByteField*/
static void JNICALL bda_c2j_proxy_SetByteField(JNIEnv * env, jobject p1, jfieldID p2, jbyte p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetByteField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetByteField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.b = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetByteField")
    && bda_check_no_exeception(s, "SetByteField")
    && bda_check_no_critical(s, "SetByteField")
    && bda_check_non_null(s, p1,  1, "SetByteField")
    && bda_check_non_null(s, p2,  2, "SetByteField")
    && bda_check_ref_dangling(s, p1, 1, "SetByteField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'B', "SetByteField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetByteField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetByteField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetByteField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetCharField*/
static void JNICALL bda_c2j_proxy_SetCharField(JNIEnv * env, jobject p1, jfieldID p2, jchar p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetCharField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetCharField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.c = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetCharField")
    && bda_check_no_exeception(s, "SetCharField")
    && bda_check_no_critical(s, "SetCharField")
    && bda_check_non_null(s, p1,  1, "SetCharField")
    && bda_check_non_null(s, p2,  2, "SetCharField")
    && bda_check_ref_dangling(s, p1, 1, "SetCharField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'C', "SetCharField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetCharField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetCharField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetCharField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetShortField*/
static void JNICALL bda_c2j_proxy_SetShortField(JNIEnv * env, jobject p1, jfieldID p2, jshort p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetShortField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetShortField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.s = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetShortField")
    && bda_check_no_exeception(s, "SetShortField")
    && bda_check_no_critical(s, "SetShortField")
    && bda_check_non_null(s, p1,  1, "SetShortField")
    && bda_check_non_null(s, p2,  2, "SetShortField")
    && bda_check_ref_dangling(s, p1, 1, "SetShortField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'S', "SetShortField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetShortField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetShortField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetShortField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetIntField*/
static void JNICALL bda_c2j_proxy_SetIntField(JNIEnv * env, jobject p1, jfieldID p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetIntField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetIntField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.i = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetIntField")
    && bda_check_no_exeception(s, "SetIntField")
    && bda_check_no_critical(s, "SetIntField")
    && bda_check_non_null(s, p1,  1, "SetIntField")
    && bda_check_non_null(s, p2,  2, "SetIntField")
    && bda_check_ref_dangling(s, p1, 1, "SetIntField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'I', "SetIntField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetIntField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetIntField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetIntField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetLongField*/
static void JNICALL bda_c2j_proxy_SetLongField(JNIEnv * env, jobject p1, jfieldID p2, jlong p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetLongField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetLongField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.j = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetLongField")
    && bda_check_no_exeception(s, "SetLongField")
    && bda_check_no_critical(s, "SetLongField")
    && bda_check_non_null(s, p1,  1, "SetLongField")
    && bda_check_non_null(s, p2,  2, "SetLongField")
    && bda_check_ref_dangling(s, p1, 1, "SetLongField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'J', "SetLongField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetLongField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetLongField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetLongField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetFloatField*/
static void JNICALL bda_c2j_proxy_SetFloatField(JNIEnv * env, jobject p1, jfieldID p2, jfloat p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetFloatField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetFloatField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.f = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetFloatField")
    && bda_check_no_exeception(s, "SetFloatField")
    && bda_check_no_critical(s, "SetFloatField")
    && bda_check_non_null(s, p1,  1, "SetFloatField")
    && bda_check_non_null(s, p2,  2, "SetFloatField")
    && bda_check_ref_dangling(s, p1, 1, "SetFloatField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'F', "SetFloatField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetFloatField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetFloatField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetFloatField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetDoubleField*/
static void JNICALL bda_c2j_proxy_SetDoubleField(JNIEnv * env, jobject p1, jfieldID p2, jdouble p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetDoubleField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetDoubleField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.d = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetDoubleField")
    && bda_check_no_exeception(s, "SetDoubleField")
    && bda_check_no_critical(s, "SetDoubleField")
    && bda_check_non_null(s, p1,  1, "SetDoubleField")
    && bda_check_non_null(s, p2,  2, "SetDoubleField")
    && bda_check_ref_dangling(s, p1, 1, "SetDoubleField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'D', "SetDoubleField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetDoubleField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetDoubleField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetDoubleField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetStaticMethodID*/
static jmethodID JNICALL bda_c2j_proxy_GetStaticMethodID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jmethodID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticMethodID++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticMethodID++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticMethodID")
    && bda_check_no_exeception(s, "GetStaticMethodID")
    && bda_check_no_critical(s, "GetStaticMethodID")
    && bda_check_non_null(s, p1,  1, "GetStaticMethodID")
    && bda_check_non_null(s, p2,  2, "GetStaticMethodID")
    && bda_check_non_null(s, p3,  3, "GetStaticMethodID")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticMethodID")
    && bda_check_jclass(s, p1, 1, "GetStaticMethodID")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticMethodID;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticMethodID(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jmethodid_append(result, 1, p1, p2, p3);
   }
  }

  return result;
}


/* proxy for CallStaticObjectMethod*/
static jobject JNICALL bda_c2j_proxy_CallStaticObjectMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticObjectMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticObjectMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticObjectMethod")
    && bda_check_no_exeception(s, "CallStaticObjectMethod")
    && bda_check_no_critical(s, "CallStaticObjectMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticObjectMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticObjectMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticObjectMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticObjectMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticObjectMethod", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticObjectMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticObjectMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallStaticObjectMethod")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for CallStaticObjectMethodV*/
static jobject JNICALL bda_c2j_proxy_CallStaticObjectMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticObjectMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticObjectMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticObjectMethodV")
    && bda_check_no_exeception(s, "CallStaticObjectMethodV")
    && bda_check_no_critical(s, "CallStaticObjectMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticObjectMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticObjectMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticObjectMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticObjectMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticObjectMethodV", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticObjectMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticObjectMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallStaticObjectMethodV")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for CallStaticObjectMethodA*/
static jobject JNICALL bda_c2j_proxy_CallStaticObjectMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticObjectMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticObjectMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticObjectMethodA")
    && bda_check_no_exeception(s, "CallStaticObjectMethodA")
    && bda_check_no_critical(s, "CallStaticObjectMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticObjectMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticObjectMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticObjectMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticObjectMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticObjectMethodA", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticObjectMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticObjectMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallStaticObjectMethodA")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for CallStaticBooleanMethod*/
static jboolean JNICALL bda_c2j_proxy_CallStaticBooleanMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticBooleanMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticBooleanMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticBooleanMethod")
    && bda_check_no_exeception(s, "CallStaticBooleanMethod")
    && bda_check_no_critical(s, "CallStaticBooleanMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticBooleanMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticBooleanMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticBooleanMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticBooleanMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticBooleanMethod", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticBooleanMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticBooleanMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticBooleanMethodV*/
static jboolean JNICALL bda_c2j_proxy_CallStaticBooleanMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticBooleanMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticBooleanMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticBooleanMethodV")
    && bda_check_no_exeception(s, "CallStaticBooleanMethodV")
    && bda_check_no_critical(s, "CallStaticBooleanMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticBooleanMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticBooleanMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticBooleanMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticBooleanMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticBooleanMethodV", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticBooleanMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticBooleanMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticBooleanMethodA*/
static jboolean JNICALL bda_c2j_proxy_CallStaticBooleanMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticBooleanMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticBooleanMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticBooleanMethodA")
    && bda_check_no_exeception(s, "CallStaticBooleanMethodA")
    && bda_check_no_critical(s, "CallStaticBooleanMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticBooleanMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticBooleanMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticBooleanMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticBooleanMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticBooleanMethodA", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticBooleanMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticBooleanMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticByteMethod*/
static jbyte JNICALL bda_c2j_proxy_CallStaticByteMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticByteMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticByteMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticByteMethod")
    && bda_check_no_exeception(s, "CallStaticByteMethod")
    && bda_check_no_critical(s, "CallStaticByteMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticByteMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticByteMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticByteMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticByteMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticByteMethod", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticByteMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticByteMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticByteMethodV*/
static jbyte JNICALL bda_c2j_proxy_CallStaticByteMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticByteMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticByteMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticByteMethodV")
    && bda_check_no_exeception(s, "CallStaticByteMethodV")
    && bda_check_no_critical(s, "CallStaticByteMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticByteMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticByteMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticByteMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticByteMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticByteMethodV", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticByteMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticByteMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticByteMethodA*/
static jbyte JNICALL bda_c2j_proxy_CallStaticByteMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticByteMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticByteMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticByteMethodA")
    && bda_check_no_exeception(s, "CallStaticByteMethodA")
    && bda_check_no_critical(s, "CallStaticByteMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticByteMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticByteMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticByteMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticByteMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticByteMethodA", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticByteMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticByteMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticCharMethod*/
static jchar JNICALL bda_c2j_proxy_CallStaticCharMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticCharMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticCharMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticCharMethod")
    && bda_check_no_exeception(s, "CallStaticCharMethod")
    && bda_check_no_critical(s, "CallStaticCharMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticCharMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticCharMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticCharMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticCharMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticCharMethod", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticCharMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticCharMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticCharMethodV*/
static jchar JNICALL bda_c2j_proxy_CallStaticCharMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticCharMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticCharMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticCharMethodV")
    && bda_check_no_exeception(s, "CallStaticCharMethodV")
    && bda_check_no_critical(s, "CallStaticCharMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticCharMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticCharMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticCharMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticCharMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticCharMethodV", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticCharMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticCharMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticCharMethodA*/
static jchar JNICALL bda_c2j_proxy_CallStaticCharMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticCharMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticCharMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticCharMethodA")
    && bda_check_no_exeception(s, "CallStaticCharMethodA")
    && bda_check_no_critical(s, "CallStaticCharMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticCharMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticCharMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticCharMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticCharMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticCharMethodA", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticCharMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticCharMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticShortMethod*/
static jshort JNICALL bda_c2j_proxy_CallStaticShortMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticShortMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticShortMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticShortMethod")
    && bda_check_no_exeception(s, "CallStaticShortMethod")
    && bda_check_no_critical(s, "CallStaticShortMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticShortMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticShortMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticShortMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticShortMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticShortMethod", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticShortMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticShortMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticShortMethodV*/
static jshort JNICALL bda_c2j_proxy_CallStaticShortMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticShortMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticShortMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticShortMethodV")
    && bda_check_no_exeception(s, "CallStaticShortMethodV")
    && bda_check_no_critical(s, "CallStaticShortMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticShortMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticShortMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticShortMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticShortMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticShortMethodV", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticShortMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticShortMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticShortMethodA*/
static jshort JNICALL bda_c2j_proxy_CallStaticShortMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticShortMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticShortMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticShortMethodA")
    && bda_check_no_exeception(s, "CallStaticShortMethodA")
    && bda_check_no_critical(s, "CallStaticShortMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticShortMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticShortMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticShortMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticShortMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticShortMethodA", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticShortMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticShortMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticIntMethod*/
static jint JNICALL bda_c2j_proxy_CallStaticIntMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticIntMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticIntMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticIntMethod")
    && bda_check_no_exeception(s, "CallStaticIntMethod")
    && bda_check_no_critical(s, "CallStaticIntMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticIntMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticIntMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticIntMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticIntMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticIntMethod", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticIntMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticIntMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticIntMethodV*/
static jint JNICALL bda_c2j_proxy_CallStaticIntMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticIntMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticIntMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticIntMethodV")
    && bda_check_no_exeception(s, "CallStaticIntMethodV")
    && bda_check_no_critical(s, "CallStaticIntMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticIntMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticIntMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticIntMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticIntMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticIntMethodV", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticIntMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticIntMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticIntMethodA*/
static jint JNICALL bda_c2j_proxy_CallStaticIntMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticIntMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticIntMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticIntMethodA")
    && bda_check_no_exeception(s, "CallStaticIntMethodA")
    && bda_check_no_critical(s, "CallStaticIntMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticIntMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticIntMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticIntMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticIntMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticIntMethodA", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticIntMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticIntMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticLongMethod*/
static jlong JNICALL bda_c2j_proxy_CallStaticLongMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticLongMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticLongMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticLongMethod")
    && bda_check_no_exeception(s, "CallStaticLongMethod")
    && bda_check_no_critical(s, "CallStaticLongMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticLongMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticLongMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticLongMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticLongMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticLongMethod", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticLongMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticLongMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticLongMethodV*/
static jlong JNICALL bda_c2j_proxy_CallStaticLongMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticLongMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticLongMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticLongMethodV")
    && bda_check_no_exeception(s, "CallStaticLongMethodV")
    && bda_check_no_critical(s, "CallStaticLongMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticLongMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticLongMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticLongMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticLongMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticLongMethodV", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticLongMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticLongMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticLongMethodA*/
static jlong JNICALL bda_c2j_proxy_CallStaticLongMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticLongMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticLongMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticLongMethodA")
    && bda_check_no_exeception(s, "CallStaticLongMethodA")
    && bda_check_no_critical(s, "CallStaticLongMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticLongMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticLongMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticLongMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticLongMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticLongMethodA", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticLongMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticLongMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticFloatMethod*/
static jfloat JNICALL bda_c2j_proxy_CallStaticFloatMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticFloatMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticFloatMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticFloatMethod")
    && bda_check_no_exeception(s, "CallStaticFloatMethod")
    && bda_check_no_critical(s, "CallStaticFloatMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticFloatMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticFloatMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticFloatMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticFloatMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticFloatMethod", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticFloatMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticFloatMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticFloatMethodV*/
static jfloat JNICALL bda_c2j_proxy_CallStaticFloatMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticFloatMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticFloatMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticFloatMethodV")
    && bda_check_no_exeception(s, "CallStaticFloatMethodV")
    && bda_check_no_critical(s, "CallStaticFloatMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticFloatMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticFloatMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticFloatMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticFloatMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticFloatMethodV", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticFloatMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticFloatMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticFloatMethodA*/
static jfloat JNICALL bda_c2j_proxy_CallStaticFloatMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticFloatMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticFloatMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticFloatMethodA")
    && bda_check_no_exeception(s, "CallStaticFloatMethodA")
    && bda_check_no_critical(s, "CallStaticFloatMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticFloatMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticFloatMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticFloatMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticFloatMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticFloatMethodA", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticFloatMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticFloatMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticDoubleMethod*/
static jdouble JNICALL bda_c2j_proxy_CallStaticDoubleMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticDoubleMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticDoubleMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticDoubleMethod")
    && bda_check_no_exeception(s, "CallStaticDoubleMethod")
    && bda_check_no_critical(s, "CallStaticDoubleMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticDoubleMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticDoubleMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticDoubleMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticDoubleMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticDoubleMethod", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticDoubleMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticDoubleMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticDoubleMethodV*/
static jdouble JNICALL bda_c2j_proxy_CallStaticDoubleMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticDoubleMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticDoubleMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticDoubleMethodV")
    && bda_check_no_exeception(s, "CallStaticDoubleMethodV")
    && bda_check_no_critical(s, "CallStaticDoubleMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticDoubleMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticDoubleMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticDoubleMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticDoubleMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticDoubleMethodV", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticDoubleMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticDoubleMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticDoubleMethodA*/
static jdouble JNICALL bda_c2j_proxy_CallStaticDoubleMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticDoubleMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticDoubleMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticDoubleMethodA")
    && bda_check_no_exeception(s, "CallStaticDoubleMethodA")
    && bda_check_no_critical(s, "CallStaticDoubleMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticDoubleMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticDoubleMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticDoubleMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticDoubleMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticDoubleMethodA", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticDoubleMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticDoubleMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for CallStaticVoidMethod*/
static void JNICALL bda_c2j_proxy_CallStaticVoidMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticVoidMethod++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticVoidMethod++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticVoidMethod")
    && bda_check_no_exeception(s, "CallStaticVoidMethod")
    && bda_check_no_critical(s, "CallStaticVoidMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticVoidMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticVoidMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticVoidMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticVoidMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticVoidMethod", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticVoidMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  bda_orig_jni_funcs->CallStaticVoidMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for CallStaticVoidMethodV*/
static void JNICALL bda_c2j_proxy_CallStaticVoidMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticVoidMethodV++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticVoidMethodV++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticVoidMethodV")
    && bda_check_no_exeception(s, "CallStaticVoidMethodV")
    && bda_check_no_critical(s, "CallStaticVoidMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticVoidMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticVoidMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticVoidMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticVoidMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticVoidMethodV", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticVoidMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallStaticVoidMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for CallStaticVoidMethodA*/
static void JNICALL bda_c2j_proxy_CallStaticVoidMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.CallStaticVoidMethodA++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.CallStaticVoidMethodA++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticVoidMethodA")
    && bda_check_no_exeception(s, "CallStaticVoidMethodA")
    && bda_check_no_critical(s, "CallStaticVoidMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticVoidMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticVoidMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticVoidMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticVoidMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticVoidMethodA", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticVoidMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallStaticVoidMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetStaticFieldID*/
static jfieldID JNICALL bda_c2j_proxy_GetStaticFieldID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jfieldID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticFieldID++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticFieldID++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticFieldID")
    && bda_check_no_exeception(s, "GetStaticFieldID")
    && bda_check_no_critical(s, "GetStaticFieldID")
    && bda_check_non_null(s, p1,  1, "GetStaticFieldID")
    && bda_check_non_null(s, p2,  2, "GetStaticFieldID")
    && bda_check_non_null(s, p3,  3, "GetStaticFieldID")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticFieldID")
    && bda_check_jclass(s, p1, 1, "GetStaticFieldID")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticFieldID;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticFieldID(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jfieldid_append(s, result, p1, 1, p2, p3);
   }
  }

  return result;
}


/* proxy for GetStaticObjectField*/
static jobject JNICALL bda_c2j_proxy_GetStaticObjectField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticObjectField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticObjectField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticObjectField")
    && bda_check_no_exeception(s, "GetStaticObjectField")
    && bda_check_no_critical(s, "GetStaticObjectField")
    && bda_check_non_null(s, p1,  1, "GetStaticObjectField")
    && bda_check_non_null(s, p2,  2, "GetStaticObjectField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticObjectField")
    && bda_check_jclass(s, p1, 1, "GetStaticObjectField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'O', "GetStaticObjectField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticObjectField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticObjectField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "GetStaticObjectField")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for GetStaticBooleanField*/
static jboolean JNICALL bda_c2j_proxy_GetStaticBooleanField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticBooleanField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticBooleanField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticBooleanField")
    && bda_check_no_exeception(s, "GetStaticBooleanField")
    && bda_check_no_critical(s, "GetStaticBooleanField")
    && bda_check_non_null(s, p1,  1, "GetStaticBooleanField")
    && bda_check_non_null(s, p2,  2, "GetStaticBooleanField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticBooleanField")
    && bda_check_jclass(s, p1, 1, "GetStaticBooleanField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'Z', "GetStaticBooleanField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticBooleanField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticBooleanField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticByteField*/
static jbyte JNICALL bda_c2j_proxy_GetStaticByteField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticByteField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticByteField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticByteField")
    && bda_check_no_exeception(s, "GetStaticByteField")
    && bda_check_no_critical(s, "GetStaticByteField")
    && bda_check_non_null(s, p1,  1, "GetStaticByteField")
    && bda_check_non_null(s, p2,  2, "GetStaticByteField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticByteField")
    && bda_check_jclass(s, p1, 1, "GetStaticByteField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'B', "GetStaticByteField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticByteField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticByteField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticCharField*/
static jchar JNICALL bda_c2j_proxy_GetStaticCharField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticCharField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticCharField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticCharField")
    && bda_check_no_exeception(s, "GetStaticCharField")
    && bda_check_no_critical(s, "GetStaticCharField")
    && bda_check_non_null(s, p1,  1, "GetStaticCharField")
    && bda_check_non_null(s, p2,  2, "GetStaticCharField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticCharField")
    && bda_check_jclass(s, p1, 1, "GetStaticCharField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'C', "GetStaticCharField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticCharField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticCharField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticShortField*/
static jshort JNICALL bda_c2j_proxy_GetStaticShortField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticShortField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticShortField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticShortField")
    && bda_check_no_exeception(s, "GetStaticShortField")
    && bda_check_no_critical(s, "GetStaticShortField")
    && bda_check_non_null(s, p1,  1, "GetStaticShortField")
    && bda_check_non_null(s, p2,  2, "GetStaticShortField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticShortField")
    && bda_check_jclass(s, p1, 1, "GetStaticShortField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'S', "GetStaticShortField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticShortField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticShortField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticIntField*/
static jint JNICALL bda_c2j_proxy_GetStaticIntField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticIntField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticIntField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticIntField")
    && bda_check_no_exeception(s, "GetStaticIntField")
    && bda_check_no_critical(s, "GetStaticIntField")
    && bda_check_non_null(s, p1,  1, "GetStaticIntField")
    && bda_check_non_null(s, p2,  2, "GetStaticIntField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticIntField")
    && bda_check_jclass(s, p1, 1, "GetStaticIntField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'I', "GetStaticIntField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticIntField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticIntField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticLongField*/
static jlong JNICALL bda_c2j_proxy_GetStaticLongField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticLongField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticLongField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticLongField")
    && bda_check_no_exeception(s, "GetStaticLongField")
    && bda_check_no_critical(s, "GetStaticLongField")
    && bda_check_non_null(s, p1,  1, "GetStaticLongField")
    && bda_check_non_null(s, p2,  2, "GetStaticLongField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticLongField")
    && bda_check_jclass(s, p1, 1, "GetStaticLongField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'J', "GetStaticLongField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticLongField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticLongField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticFloatField*/
static jfloat JNICALL bda_c2j_proxy_GetStaticFloatField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticFloatField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticFloatField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticFloatField")
    && bda_check_no_exeception(s, "GetStaticFloatField")
    && bda_check_no_critical(s, "GetStaticFloatField")
    && bda_check_non_null(s, p1,  1, "GetStaticFloatField")
    && bda_check_non_null(s, p2,  2, "GetStaticFloatField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticFloatField")
    && bda_check_jclass(s, p1, 1, "GetStaticFloatField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'F', "GetStaticFloatField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticFloatField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticFloatField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStaticDoubleField*/
static jdouble JNICALL bda_c2j_proxy_GetStaticDoubleField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStaticDoubleField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStaticDoubleField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticDoubleField")
    && bda_check_no_exeception(s, "GetStaticDoubleField")
    && bda_check_no_critical(s, "GetStaticDoubleField")
    && bda_check_non_null(s, p1,  1, "GetStaticDoubleField")
    && bda_check_non_null(s, p2,  2, "GetStaticDoubleField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticDoubleField")
    && bda_check_jclass(s, p1, 1, "GetStaticDoubleField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'D', "GetStaticDoubleField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticDoubleField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticDoubleField(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for SetStaticObjectField*/
static void JNICALL bda_c2j_proxy_SetStaticObjectField(JNIEnv * env, jclass p1, jfieldID p2, jobject p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetStaticObjectField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticObjectField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.l = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticObjectField")
    && bda_check_no_exeception(s, "SetStaticObjectField")
    && bda_check_no_critical(s, "SetStaticObjectField")
    && bda_check_non_null(s, p1,  1, "SetStaticObjectField")
    && bda_check_non_null(s, p2,  2, "SetStaticObjectField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticObjectField")
    && bda_check_jclass(s, p1, 1, "SetStaticObjectField")
    && bda_check_ref_dangling(s, p3, 3, "SetStaticObjectField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'O', "SetStaticObjectField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticObjectField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticObjectField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticObjectField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticBooleanField*/
static void JNICALL bda_c2j_proxy_SetStaticBooleanField(JNIEnv * env, jclass p1, jfieldID p2, jboolean p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetStaticBooleanField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticBooleanField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.z = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticBooleanField")
    && bda_check_no_exeception(s, "SetStaticBooleanField")
    && bda_check_no_critical(s, "SetStaticBooleanField")
    && bda_check_non_null(s, p1,  1, "SetStaticBooleanField")
    && bda_check_non_null(s, p2,  2, "SetStaticBooleanField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticBooleanField")
    && bda_check_jclass(s, p1, 1, "SetStaticBooleanField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'Z', "SetStaticBooleanField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticBooleanField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticBooleanField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticBooleanField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticByteField*/
static void JNICALL bda_c2j_proxy_SetStaticByteField(JNIEnv * env, jclass p1, jfieldID p2, jbyte p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetStaticByteField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticByteField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.b = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticByteField")
    && bda_check_no_exeception(s, "SetStaticByteField")
    && bda_check_no_critical(s, "SetStaticByteField")
    && bda_check_non_null(s, p1,  1, "SetStaticByteField")
    && bda_check_non_null(s, p2,  2, "SetStaticByteField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticByteField")
    && bda_check_jclass(s, p1, 1, "SetStaticByteField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'B', "SetStaticByteField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticByteField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticByteField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticByteField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticCharField*/
static void JNICALL bda_c2j_proxy_SetStaticCharField(JNIEnv * env, jclass p1, jfieldID p2, jchar p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetStaticCharField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticCharField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.c = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticCharField")
    && bda_check_no_exeception(s, "SetStaticCharField")
    && bda_check_no_critical(s, "SetStaticCharField")
    && bda_check_non_null(s, p1,  1, "SetStaticCharField")
    && bda_check_non_null(s, p2,  2, "SetStaticCharField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticCharField")
    && bda_check_jclass(s, p1, 1, "SetStaticCharField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'C', "SetStaticCharField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticCharField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticCharField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticCharField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticShortField*/
static void JNICALL bda_c2j_proxy_SetStaticShortField(JNIEnv * env, jclass p1, jfieldID p2, jshort p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetStaticShortField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticShortField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.s = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticShortField")
    && bda_check_no_exeception(s, "SetStaticShortField")
    && bda_check_no_critical(s, "SetStaticShortField")
    && bda_check_non_null(s, p1,  1, "SetStaticShortField")
    && bda_check_non_null(s, p2,  2, "SetStaticShortField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticShortField")
    && bda_check_jclass(s, p1, 1, "SetStaticShortField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'S', "SetStaticShortField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticShortField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticShortField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticShortField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticIntField*/
static void JNICALL bda_c2j_proxy_SetStaticIntField(JNIEnv * env, jclass p1, jfieldID p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetStaticIntField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticIntField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.i = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticIntField")
    && bda_check_no_exeception(s, "SetStaticIntField")
    && bda_check_no_critical(s, "SetStaticIntField")
    && bda_check_non_null(s, p1,  1, "SetStaticIntField")
    && bda_check_non_null(s, p2,  2, "SetStaticIntField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticIntField")
    && bda_check_jclass(s, p1, 1, "SetStaticIntField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'I', "SetStaticIntField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticIntField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticIntField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticIntField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticLongField*/
static void JNICALL bda_c2j_proxy_SetStaticLongField(JNIEnv * env, jclass p1, jfieldID p2, jlong p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetStaticLongField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticLongField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.j = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticLongField")
    && bda_check_no_exeception(s, "SetStaticLongField")
    && bda_check_no_critical(s, "SetStaticLongField")
    && bda_check_non_null(s, p1,  1, "SetStaticLongField")
    && bda_check_non_null(s, p2,  2, "SetStaticLongField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticLongField")
    && bda_check_jclass(s, p1, 1, "SetStaticLongField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'J', "SetStaticLongField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticLongField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticLongField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticLongField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticFloatField*/
static void JNICALL bda_c2j_proxy_SetStaticFloatField(JNIEnv * env, jclass p1, jfieldID p2, jfloat p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetStaticFloatField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticFloatField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.f = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticFloatField")
    && bda_check_no_exeception(s, "SetStaticFloatField")
    && bda_check_no_critical(s, "SetStaticFloatField")
    && bda_check_non_null(s, p1,  1, "SetStaticFloatField")
    && bda_check_non_null(s, p2,  2, "SetStaticFloatField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticFloatField")
    && bda_check_jclass(s, p1, 1, "SetStaticFloatField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'F', "SetStaticFloatField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticFloatField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticFloatField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticFloatField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetStaticDoubleField*/
static void JNICALL bda_c2j_proxy_SetStaticDoubleField(JNIEnv * env, jclass p1, jfieldID p2, jdouble p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetStaticDoubleField++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetStaticDoubleField++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.d = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticDoubleField")
    && bda_check_no_exeception(s, "SetStaticDoubleField")
    && bda_check_no_critical(s, "SetStaticDoubleField")
    && bda_check_non_null(s, p1,  1, "SetStaticDoubleField")
    && bda_check_non_null(s, p2,  2, "SetStaticDoubleField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticDoubleField")
    && bda_check_jclass(s, p1, 1, "SetStaticDoubleField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'D', "SetStaticDoubleField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticDoubleField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticDoubleField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticDoubleField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for NewString*/
static jstring JNICALL bda_c2j_proxy_NewString(JNIEnv * env, const jchar * p1, jsize p2)
{
  /* local variables */
  jstring result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewString++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewString++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewString")
    && bda_check_no_exeception(s, "NewString")
    && bda_check_no_critical(s, "NewString")
    && bda_check_non_null(s, p1,  1, "NewString")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewString;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewString(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewString")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for GetStringLength*/
static jsize JNICALL bda_c2j_proxy_GetStringLength(JNIEnv * env, jstring p1)
{
  /* local variables */
  jsize result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStringLength++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringLength++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringLength")
    && bda_check_no_exeception(s, "GetStringLength")
    && bda_check_no_critical(s, "GetStringLength")
    && bda_check_non_null(s, p1,  1, "GetStringLength")
    && bda_check_ref_dangling(s, p1, 1, "GetStringLength")
    && bda_check_jstring(s, p1, 1, "GetStringLength")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringLength;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringLength(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStringChars*/
static const jchar * JNICALL bda_c2j_proxy_GetStringChars(JNIEnv * env, jstring p1, jboolean * p2)
{
  /* local variables */
  const jchar * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStringChars++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringChars++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringChars")
    && bda_check_no_exeception(s, "GetStringChars")
    && bda_check_no_critical(s, "GetStringChars")
    && bda_check_non_null(s, p1,  1, "GetStringChars")
    && bda_check_ref_dangling(s, p1, 1, "GetStringChars")
    && bda_check_jstring(s, p1, 1, "GetStringChars")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringChars;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringChars(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetStringChars");}
  }

  return result;
}


/* proxy for ReleaseStringChars*/
static void JNICALL bda_c2j_proxy_ReleaseStringChars(JNIEnv * env, jstring p1, const jchar * p2)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseStringChars++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseStringChars++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseStringChars")
    && bda_check_no_critical(s, "ReleaseStringChars")
    && bda_check_non_null(s, p1,  1, "ReleaseStringChars")
    && bda_check_non_null(s, p2,  2, "ReleaseStringChars")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseStringChars"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jstring(s, p1, 1, "ReleaseStringChars"))
    && bda_check_resource_free(s, p2, "ReleaseStringChars")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseStringChars;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseStringChars(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    bda_resource_release(s, p2, "ReleaseStringChars");
  }

}


/* proxy for NewStringUTF*/
static jstring JNICALL bda_c2j_proxy_NewStringUTF(JNIEnv * env, const char * p1)
{
  /* local variables */
  jstring result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewStringUTF++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewStringUTF++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewStringUTF")
    && bda_check_no_exeception(s, "NewStringUTF")
    && bda_check_no_critical(s, "NewStringUTF")
    && bda_check_non_null(s, p1,  1, "NewStringUTF")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewStringUTF;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewStringUTF(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewStringUTF")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for GetStringUTFLength*/
static jsize JNICALL bda_c2j_proxy_GetStringUTFLength(JNIEnv * env, jstring p1)
{
  /* local variables */
  jsize result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStringUTFLength++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringUTFLength++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringUTFLength")
    && bda_check_no_exeception(s, "GetStringUTFLength")
    && bda_check_no_critical(s, "GetStringUTFLength")
    && bda_check_non_null(s, p1,  1, "GetStringUTFLength")
    && bda_check_ref_dangling(s, p1, 1, "GetStringUTFLength")
    && bda_check_jstring(s, p1, 1, "GetStringUTFLength")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringUTFLength;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringUTFLength(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStringUTFChars*/
static const char * JNICALL bda_c2j_proxy_GetStringUTFChars(JNIEnv * env, jstring p1, jboolean * p2)
{
  /* local variables */
  const char * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStringUTFChars++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringUTFChars++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringUTFChars")
    && bda_check_no_exeception(s, "GetStringUTFChars")
    && bda_check_no_critical(s, "GetStringUTFChars")
    && bda_check_non_null(s, p1,  1, "GetStringUTFChars")
    && bda_check_ref_dangling(s, p1, 1, "GetStringUTFChars")
    && bda_check_jstring(s, p1, 1, "GetStringUTFChars")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringUTFChars;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringUTFChars(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetStringUTFChars");}
  }

  return result;
}


/* proxy for ReleaseStringUTFChars*/
static void JNICALL bda_c2j_proxy_ReleaseStringUTFChars(JNIEnv * env, jstring p1, const char * p2)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseStringUTFChars++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseStringUTFChars++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseStringUTFChars")
    && bda_check_no_critical(s, "ReleaseStringUTFChars")
    && bda_check_non_null(s, p1,  1, "ReleaseStringUTFChars")
    && bda_check_non_null(s, p2,  2, "ReleaseStringUTFChars")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseStringUTFChars"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jstring(s, p1, 1, "ReleaseStringUTFChars"))
    && bda_check_resource_free(s, p2, "ReleaseStringUTFChars")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseStringUTFChars;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseStringUTFChars(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    bda_resource_release(s, p2, "ReleaseStringUTFChars");
  }

}


/* proxy for GetArrayLength*/
static jsize JNICALL bda_c2j_proxy_GetArrayLength(JNIEnv * env, jarray p1)
{
  /* local variables */
  jsize result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetArrayLength++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetArrayLength++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetArrayLength")
    && bda_check_no_exeception(s, "GetArrayLength")
    && bda_check_no_critical(s, "GetArrayLength")
    && bda_check_non_null(s, p1,  1, "GetArrayLength")
    && bda_check_ref_dangling(s, p1, 1, "GetArrayLength")
    && bda_check_jarray(s, p1, 1, "GetArrayLength")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetArrayLength;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetArrayLength(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for NewObjectArray*/
static jobjectArray JNICALL bda_c2j_proxy_NewObjectArray(JNIEnv * env, jsize p1, jclass p2, jobject p3)
{
  /* local variables */
  jobjectArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewObjectArray++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewObjectArray++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewObjectArray")
    && bda_check_no_exeception(s, "NewObjectArray")
    && bda_check_no_critical(s, "NewObjectArray")
    && bda_check_non_null(s, p2,  2, "NewObjectArray")
    && bda_check_ref_dangling(s, p2, 2, "NewObjectArray")
    && bda_check_jclass(s, p2, 2, "NewObjectArray")
    && bda_check_ref_dangling(s, p3, 3, "NewObjectArray")
    && bda_check_assignable_jclass_jobject(s, p2, p3, 2, "NewObjectArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObjectArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewObjectArray(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewObjectArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for GetObjectArrayElement*/
static jobject JNICALL bda_c2j_proxy_GetObjectArrayElement(JNIEnv * env, jobjectArray p1, jsize p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetObjectArrayElement++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetObjectArrayElement++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectArrayElement")
    && bda_check_no_exeception(s, "GetObjectArrayElement")
    && bda_check_no_critical(s, "GetObjectArrayElement")
    && bda_check_non_null(s, p1,  1, "GetObjectArrayElement")
    && bda_check_ref_dangling(s, p1, 1, "GetObjectArrayElement")
    && bda_check_jobjectArray(s, p1, 1, "GetObjectArrayElement")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectArrayElement;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectArrayElement(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "GetObjectArrayElement")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for SetObjectArrayElement*/
static void JNICALL bda_c2j_proxy_SetObjectArrayElement(JNIEnv * env, jobjectArray p1, jsize p2, jobject p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetObjectArrayElement++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetObjectArrayElement++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetObjectArrayElement")
    && bda_check_no_exeception(s, "SetObjectArrayElement")
    && bda_check_no_critical(s, "SetObjectArrayElement")
    && bda_check_non_null(s, p1,  1, "SetObjectArrayElement")
    && bda_check_non_null(s, p3,  3, "SetObjectArrayElement")
    && bda_check_ref_dangling(s, p1, 1, "SetObjectArrayElement")
    && bda_check_jobjectArray(s, p1, 1, "SetObjectArrayElement")
    && bda_check_ref_dangling(s, p3, 3, "SetObjectArrayElement")
    && bda_check_assignable_jobjectArray_jobject(s, p1, p3, 3,  "SetObjectArrayElement")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetObjectArrayElement;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetObjectArrayElement(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for NewBooleanArray*/
static jbooleanArray JNICALL bda_c2j_proxy_NewBooleanArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jbooleanArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewBooleanArray++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewBooleanArray++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewBooleanArray")
    && bda_check_no_exeception(s, "NewBooleanArray")
    && bda_check_no_critical(s, "NewBooleanArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewBooleanArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewBooleanArray(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewBooleanArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewByteArray*/
static jbyteArray JNICALL bda_c2j_proxy_NewByteArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jbyteArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewByteArray++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewByteArray++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewByteArray")
    && bda_check_no_exeception(s, "NewByteArray")
    && bda_check_no_critical(s, "NewByteArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewByteArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewByteArray(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewByteArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewCharArray*/
static jcharArray JNICALL bda_c2j_proxy_NewCharArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jcharArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewCharArray++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewCharArray++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewCharArray")
    && bda_check_no_exeception(s, "NewCharArray")
    && bda_check_no_critical(s, "NewCharArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewCharArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewCharArray(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewCharArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewShortArray*/
static jshortArray JNICALL bda_c2j_proxy_NewShortArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jshortArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewShortArray++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewShortArray++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewShortArray")
    && bda_check_no_exeception(s, "NewShortArray")
    && bda_check_no_critical(s, "NewShortArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewShortArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewShortArray(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewShortArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewIntArray*/
static jintArray JNICALL bda_c2j_proxy_NewIntArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jintArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewIntArray++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewIntArray++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewIntArray")
    && bda_check_no_exeception(s, "NewIntArray")
    && bda_check_no_critical(s, "NewIntArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewIntArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewIntArray(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewIntArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewLongArray*/
static jlongArray JNICALL bda_c2j_proxy_NewLongArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jlongArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewLongArray++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewLongArray++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewLongArray")
    && bda_check_no_exeception(s, "NewLongArray")
    && bda_check_no_critical(s, "NewLongArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewLongArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewLongArray(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewLongArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewFloatArray*/
static jfloatArray JNICALL bda_c2j_proxy_NewFloatArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jfloatArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewFloatArray++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewFloatArray++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewFloatArray")
    && bda_check_no_exeception(s, "NewFloatArray")
    && bda_check_no_critical(s, "NewFloatArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewFloatArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewFloatArray(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewFloatArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for NewDoubleArray*/
static jdoubleArray JNICALL bda_c2j_proxy_NewDoubleArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jdoubleArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewDoubleArray++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewDoubleArray++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewDoubleArray")
    && bda_check_no_exeception(s, "NewDoubleArray")
    && bda_check_no_critical(s, "NewDoubleArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewDoubleArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewDoubleArray(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewDoubleArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for GetBooleanArrayElements*/
static jboolean * JNICALL bda_c2j_proxy_GetBooleanArrayElements(JNIEnv * env, jbooleanArray p1, jboolean * p2)
{
  /* local variables */
  jboolean * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetBooleanArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetBooleanArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetBooleanArrayElements")
    && bda_check_no_exeception(s, "GetBooleanArrayElements")
    && bda_check_no_critical(s, "GetBooleanArrayElements")
    && bda_check_non_null(s, p1,  1, "GetBooleanArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetBooleanArrayElements")
    && bda_check_jbooleanArray(s, p1, 1, "GetBooleanArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetBooleanArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetBooleanArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetBooleanArrayElements");}
  }

  return result;
}


/* proxy for GetByteArrayElements*/
static jbyte * JNICALL bda_c2j_proxy_GetByteArrayElements(JNIEnv * env, jbyteArray p1, jboolean * p2)
{
  /* local variables */
  jbyte * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetByteArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetByteArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetByteArrayElements")
    && bda_check_no_exeception(s, "GetByteArrayElements")
    && bda_check_no_critical(s, "GetByteArrayElements")
    && bda_check_non_null(s, p1,  1, "GetByteArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetByteArrayElements")
    && bda_check_jbyteArray(s, p1, 1, "GetByteArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetByteArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetByteArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetByteArrayElements");}
  }

  return result;
}


/* proxy for GetCharArrayElements*/
static jchar * JNICALL bda_c2j_proxy_GetCharArrayElements(JNIEnv * env, jcharArray p1, jboolean * p2)
{
  /* local variables */
  jchar * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetCharArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetCharArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetCharArrayElements")
    && bda_check_no_exeception(s, "GetCharArrayElements")
    && bda_check_no_critical(s, "GetCharArrayElements")
    && bda_check_non_null(s, p1,  1, "GetCharArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetCharArrayElements")
    && bda_check_jcharArray(s, p1, 1, "GetCharArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetCharArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetCharArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetCharArrayElements");}
  }

  return result;
}


/* proxy for GetShortArrayElements*/
static jshort * JNICALL bda_c2j_proxy_GetShortArrayElements(JNIEnv * env, jshortArray p1, jboolean * p2)
{
  /* local variables */
  jshort * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetShortArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetShortArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetShortArrayElements")
    && bda_check_no_exeception(s, "GetShortArrayElements")
    && bda_check_no_critical(s, "GetShortArrayElements")
    && bda_check_non_null(s, p1,  1, "GetShortArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetShortArrayElements")
    && bda_check_jshortArray(s, p1, 1, "GetShortArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetShortArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetShortArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetShortArrayElements");}
  }

  return result;
}


/* proxy for GetIntArrayElements*/
static jint * JNICALL bda_c2j_proxy_GetIntArrayElements(JNIEnv * env, jintArray p1, jboolean * p2)
{
  /* local variables */
  jint * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetIntArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetIntArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetIntArrayElements")
    && bda_check_no_exeception(s, "GetIntArrayElements")
    && bda_check_no_critical(s, "GetIntArrayElements")
    && bda_check_non_null(s, p1,  1, "GetIntArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetIntArrayElements")
    && bda_check_jintArray(s, p1, 1, "GetIntArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetIntArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetIntArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetIntArrayElements");}
  }

  return result;
}


/* proxy for GetLongArrayElements*/
static jlong * JNICALL bda_c2j_proxy_GetLongArrayElements(JNIEnv * env, jlongArray p1, jboolean * p2)
{
  /* local variables */
  jlong * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetLongArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetLongArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetLongArrayElements")
    && bda_check_no_exeception(s, "GetLongArrayElements")
    && bda_check_no_critical(s, "GetLongArrayElements")
    && bda_check_non_null(s, p1,  1, "GetLongArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetLongArrayElements")
    && bda_check_jlongArray(s, p1, 1, "GetLongArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetLongArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetLongArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetLongArrayElements");}
  }

  return result;
}


/* proxy for GetFloatArrayElements*/
static jfloat * JNICALL bda_c2j_proxy_GetFloatArrayElements(JNIEnv * env, jfloatArray p1, jboolean * p2)
{
  /* local variables */
  jfloat * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetFloatArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetFloatArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFloatArrayElements")
    && bda_check_no_exeception(s, "GetFloatArrayElements")
    && bda_check_no_critical(s, "GetFloatArrayElements")
    && bda_check_non_null(s, p1,  1, "GetFloatArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetFloatArrayElements")
    && bda_check_jfloatArray(s, p1, 1, "GetFloatArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFloatArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetFloatArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetFloatArrayElements");}
  }

  return result;
}


/* proxy for GetDoubleArrayElements*/
static jdouble * JNICALL bda_c2j_proxy_GetDoubleArrayElements(JNIEnv * env, jdoubleArray p1, jboolean * p2)
{
  /* local variables */
  jdouble * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetDoubleArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetDoubleArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDoubleArrayElements")
    && bda_check_no_exeception(s, "GetDoubleArrayElements")
    && bda_check_no_critical(s, "GetDoubleArrayElements")
    && bda_check_non_null(s, p1,  1, "GetDoubleArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetDoubleArrayElements")
    && bda_check_jdoubleArray(s, p1, 1, "GetDoubleArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDoubleArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDoubleArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetDoubleArrayElements");}
  }

  return result;
}


/* proxy for ReleaseBooleanArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseBooleanArrayElements(JNIEnv * env, jbooleanArray p1, jboolean * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseBooleanArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseBooleanArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseBooleanArrayElements")
    && bda_check_no_critical(s, "ReleaseBooleanArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseBooleanArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseBooleanArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseBooleanArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jbooleanArray(s, p1, 1, "ReleaseBooleanArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseBooleanArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseBooleanArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseBooleanArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseBooleanArrayElements");}
  }

}


/* proxy for ReleaseByteArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseByteArrayElements(JNIEnv * env, jbyteArray p1, jbyte * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseByteArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseByteArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseByteArrayElements")
    && bda_check_no_critical(s, "ReleaseByteArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseByteArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseByteArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseByteArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jbyteArray(s, p1, 1, "ReleaseByteArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseByteArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseByteArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseByteArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseByteArrayElements");}
  }

}


/* proxy for ReleaseCharArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseCharArrayElements(JNIEnv * env, jcharArray p1, jchar * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseCharArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseCharArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseCharArrayElements")
    && bda_check_no_critical(s, "ReleaseCharArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseCharArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseCharArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseCharArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jcharArray(s, p1, 1, "ReleaseCharArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseCharArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseCharArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseCharArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseCharArrayElements");}
  }

}


/* proxy for ReleaseShortArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseShortArrayElements(JNIEnv * env, jshortArray p1, jshort * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseShortArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseShortArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseShortArrayElements")
    && bda_check_no_critical(s, "ReleaseShortArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseShortArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseShortArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseShortArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jshortArray(s, p1, 1, "ReleaseShortArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseShortArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseShortArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseShortArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseShortArrayElements");}
  }

}


/* proxy for ReleaseIntArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseIntArrayElements(JNIEnv * env, jintArray p1, jint * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseIntArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseIntArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseIntArrayElements")
    && bda_check_no_critical(s, "ReleaseIntArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseIntArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseIntArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseIntArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jintArray(s, p1, 1, "ReleaseIntArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseIntArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseIntArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseIntArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseIntArrayElements");}
  }

}


/* proxy for ReleaseLongArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseLongArrayElements(JNIEnv * env, jlongArray p1, jlong * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseLongArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseLongArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseLongArrayElements")
    && bda_check_no_critical(s, "ReleaseLongArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseLongArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseLongArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseLongArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jlongArray(s, p1, 1, "ReleaseLongArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseLongArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseLongArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseLongArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseLongArrayElements");}
  }

}


/* proxy for ReleaseFloatArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseFloatArrayElements(JNIEnv * env, jfloatArray p1, jfloat * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseFloatArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseFloatArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseFloatArrayElements")
    && bda_check_no_critical(s, "ReleaseFloatArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseFloatArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseFloatArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseFloatArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jfloatArray(s, p1, 1, "ReleaseFloatArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseFloatArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseFloatArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseFloatArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseFloatArrayElements");}
  }

}


/* proxy for ReleaseDoubleArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseDoubleArrayElements(JNIEnv * env, jdoubleArray p1, jdouble * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseDoubleArrayElements++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseDoubleArrayElements++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseDoubleArrayElements")
    && bda_check_no_critical(s, "ReleaseDoubleArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseDoubleArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseDoubleArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseDoubleArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jdoubleArray(s, p1, 1, "ReleaseDoubleArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseDoubleArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseDoubleArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseDoubleArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseDoubleArrayElements");}
  }

}


/* proxy for GetBooleanArrayRegion*/
static void JNICALL bda_c2j_proxy_GetBooleanArrayRegion(JNIEnv * env, jbooleanArray p1, jsize p2, jsize p3, jboolean * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetBooleanArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetBooleanArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetBooleanArrayRegion")
    && bda_check_no_exeception(s, "GetBooleanArrayRegion")
    && bda_check_no_critical(s, "GetBooleanArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetBooleanArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetBooleanArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetBooleanArrayRegion")
    && bda_check_jbooleanArray(s, p1, 1, "GetBooleanArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetBooleanArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetBooleanArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetByteArrayRegion*/
static void JNICALL bda_c2j_proxy_GetByteArrayRegion(JNIEnv * env, jbyteArray p1, jsize p2, jsize p3, jbyte * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetByteArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetByteArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetByteArrayRegion")
    && bda_check_no_exeception(s, "GetByteArrayRegion")
    && bda_check_no_critical(s, "GetByteArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetByteArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetByteArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetByteArrayRegion")
    && bda_check_jbyteArray(s, p1, 1, "GetByteArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetByteArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetByteArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetCharArrayRegion*/
static void JNICALL bda_c2j_proxy_GetCharArrayRegion(JNIEnv * env, jcharArray p1, jsize p2, jsize p3, jchar * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetCharArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetCharArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetCharArrayRegion")
    && bda_check_no_exeception(s, "GetCharArrayRegion")
    && bda_check_no_critical(s, "GetCharArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetCharArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetCharArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetCharArrayRegion")
    && bda_check_jcharArray(s, p1, 1, "GetCharArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetCharArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetCharArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetShortArrayRegion*/
static void JNICALL bda_c2j_proxy_GetShortArrayRegion(JNIEnv * env, jshortArray p1, jsize p2, jsize p3, jshort * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetShortArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetShortArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetShortArrayRegion")
    && bda_check_no_exeception(s, "GetShortArrayRegion")
    && bda_check_no_critical(s, "GetShortArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetShortArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetShortArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetShortArrayRegion")
    && bda_check_jshortArray(s, p1, 1, "GetShortArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetShortArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetShortArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetIntArrayRegion*/
static void JNICALL bda_c2j_proxy_GetIntArrayRegion(JNIEnv * env, jintArray p1, jsize p2, jsize p3, jint * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetIntArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetIntArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetIntArrayRegion")
    && bda_check_no_exeception(s, "GetIntArrayRegion")
    && bda_check_no_critical(s, "GetIntArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetIntArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetIntArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetIntArrayRegion")
    && bda_check_jintArray(s, p1, 1, "GetIntArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetIntArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetIntArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetLongArrayRegion*/
static void JNICALL bda_c2j_proxy_GetLongArrayRegion(JNIEnv * env, jlongArray p1, jsize p2, jsize p3, jlong * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetLongArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetLongArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetLongArrayRegion")
    && bda_check_no_exeception(s, "GetLongArrayRegion")
    && bda_check_no_critical(s, "GetLongArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetLongArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetLongArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetLongArrayRegion")
    && bda_check_jlongArray(s, p1, 1, "GetLongArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetLongArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetLongArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetFloatArrayRegion*/
static void JNICALL bda_c2j_proxy_GetFloatArrayRegion(JNIEnv * env, jfloatArray p1, jsize p2, jsize p3, jfloat * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetFloatArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetFloatArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFloatArrayRegion")
    && bda_check_no_exeception(s, "GetFloatArrayRegion")
    && bda_check_no_critical(s, "GetFloatArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetFloatArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetFloatArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetFloatArrayRegion")
    && bda_check_jfloatArray(s, p1, 1, "GetFloatArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFloatArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetFloatArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetDoubleArrayRegion*/
static void JNICALL bda_c2j_proxy_GetDoubleArrayRegion(JNIEnv * env, jdoubleArray p1, jsize p2, jsize p3, jdouble * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetDoubleArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetDoubleArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDoubleArrayRegion")
    && bda_check_no_exeception(s, "GetDoubleArrayRegion")
    && bda_check_no_critical(s, "GetDoubleArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetDoubleArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetDoubleArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetDoubleArrayRegion")
    && bda_check_jdoubleArray(s, p1, 1, "GetDoubleArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDoubleArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetDoubleArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetBooleanArrayRegion*/
static void JNICALL bda_c2j_proxy_SetBooleanArrayRegion(JNIEnv * env, jbooleanArray p1, jsize p2, jsize p3, const jboolean * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetBooleanArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetBooleanArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetBooleanArrayRegion")
    && bda_check_no_exeception(s, "SetBooleanArrayRegion")
    && bda_check_no_critical(s, "SetBooleanArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetBooleanArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetBooleanArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetBooleanArrayRegion")
    && bda_check_jbooleanArray(s, p1, 1, "SetBooleanArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetBooleanArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetBooleanArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetByteArrayRegion*/
static void JNICALL bda_c2j_proxy_SetByteArrayRegion(JNIEnv * env, jbyteArray p1, jsize p2, jsize p3, const jbyte * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetByteArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetByteArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetByteArrayRegion")
    && bda_check_no_exeception(s, "SetByteArrayRegion")
    && bda_check_no_critical(s, "SetByteArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetByteArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetByteArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetByteArrayRegion")
    && bda_check_jbyteArray(s, p1, 1, "SetByteArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetByteArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetByteArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetCharArrayRegion*/
static void JNICALL bda_c2j_proxy_SetCharArrayRegion(JNIEnv * env, jcharArray p1, jsize p2, jsize p3, const jchar * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetCharArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetCharArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetCharArrayRegion")
    && bda_check_no_exeception(s, "SetCharArrayRegion")
    && bda_check_no_critical(s, "SetCharArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetCharArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetCharArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetCharArrayRegion")
    && bda_check_jcharArray(s, p1, 1, "SetCharArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetCharArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetCharArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetShortArrayRegion*/
static void JNICALL bda_c2j_proxy_SetShortArrayRegion(JNIEnv * env, jshortArray p1, jsize p2, jsize p3, const jshort * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetShortArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetShortArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetShortArrayRegion")
    && bda_check_no_exeception(s, "SetShortArrayRegion")
    && bda_check_no_critical(s, "SetShortArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetShortArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetShortArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetShortArrayRegion")
    && bda_check_jshortArray(s, p1, 1, "SetShortArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetShortArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetShortArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetIntArrayRegion*/
static void JNICALL bda_c2j_proxy_SetIntArrayRegion(JNIEnv * env, jintArray p1, jsize p2, jsize p3, const jint * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetIntArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetIntArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetIntArrayRegion")
    && bda_check_no_exeception(s, "SetIntArrayRegion")
    && bda_check_no_critical(s, "SetIntArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetIntArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetIntArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetIntArrayRegion")
    && bda_check_jintArray(s, p1, 1, "SetIntArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetIntArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetIntArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetLongArrayRegion*/
static void JNICALL bda_c2j_proxy_SetLongArrayRegion(JNIEnv * env, jlongArray p1, jsize p2, jsize p3, const jlong * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetLongArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetLongArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetLongArrayRegion")
    && bda_check_no_exeception(s, "SetLongArrayRegion")
    && bda_check_no_critical(s, "SetLongArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetLongArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetLongArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetLongArrayRegion")
    && bda_check_jlongArray(s, p1, 1, "SetLongArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetLongArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetLongArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetFloatArrayRegion*/
static void JNICALL bda_c2j_proxy_SetFloatArrayRegion(JNIEnv * env, jfloatArray p1, jsize p2, jsize p3, const jfloat * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetFloatArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetFloatArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetFloatArrayRegion")
    && bda_check_no_exeception(s, "SetFloatArrayRegion")
    && bda_check_no_critical(s, "SetFloatArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetFloatArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetFloatArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetFloatArrayRegion")
    && bda_check_jfloatArray(s, p1, 1, "SetFloatArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetFloatArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetFloatArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for SetDoubleArrayRegion*/
static void JNICALL bda_c2j_proxy_SetDoubleArrayRegion(JNIEnv * env, jdoubleArray p1, jsize p2, jsize p3, const jdouble * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.SetDoubleArrayRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.SetDoubleArrayRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetDoubleArrayRegion")
    && bda_check_no_exeception(s, "SetDoubleArrayRegion")
    && bda_check_no_critical(s, "SetDoubleArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetDoubleArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetDoubleArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetDoubleArrayRegion")
    && bda_check_jdoubleArray(s, p1, 1, "SetDoubleArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetDoubleArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetDoubleArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for RegisterNatives*/
static jint JNICALL bda_c2j_proxy_RegisterNatives(JNIEnv * env, jclass p1, const JNINativeMethod * p2, jint p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.RegisterNatives++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.RegisterNatives++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "RegisterNatives")
    && bda_check_no_exeception(s, "RegisterNatives")
    && bda_check_no_critical(s, "RegisterNatives")
    && bda_check_non_null(s, p1,  1, "RegisterNatives")
    && bda_check_non_null(s, p2,  2, "RegisterNatives")
    && bda_check_ref_dangling(s, p1, 1, "RegisterNatives")
    && bda_check_jclass(s, p1, 1, "RegisterNatives")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_RegisterNatives;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->RegisterNatives(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for UnregisterNatives*/
static jint JNICALL bda_c2j_proxy_UnregisterNatives(JNIEnv * env, jclass p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.UnregisterNatives++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.UnregisterNatives++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "UnregisterNatives")
    && bda_check_no_exeception(s, "UnregisterNatives")
    && bda_check_no_critical(s, "UnregisterNatives")
    && bda_check_non_null(s, p1,  1, "UnregisterNatives")
    && bda_check_ref_dangling(s, p1, 1, "UnregisterNatives")
    && bda_check_jclass(s, p1, 1, "UnregisterNatives")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_UnregisterNatives;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->UnregisterNatives(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for MonitorEnter*/
static jint JNICALL bda_c2j_proxy_MonitorEnter(JNIEnv * env, jobject p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.MonitorEnter++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.MonitorEnter++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "MonitorEnter")
    && bda_check_no_exeception(s, "MonitorEnter")
    && bda_check_no_critical(s, "MonitorEnter")
    && bda_check_non_null(s, p1,  1, "MonitorEnter")
    && bda_check_ref_dangling(s, p1, 1, "MonitorEnter")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_MonitorEnter;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->MonitorEnter(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result == 0) {
     bda_monitor_enter(s, p1);
   }
  }

  return result;
}


/* proxy for MonitorExit*/
static jint JNICALL bda_c2j_proxy_MonitorExit(JNIEnv * env, jobject p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.MonitorExit++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.MonitorExit++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "MonitorExit")
    && bda_check_no_critical(s, "MonitorExit")
    && bda_check_non_null(s, p1,  1, "MonitorExit")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "MonitorExit"))
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_MonitorExit;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->MonitorExit(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result == 0) {
     bda_monitor_exit(s, p1);
   }
  }

  return result;
}


/* proxy for GetJavaVM*/
static jint JNICALL bda_c2j_proxy_GetJavaVM(JNIEnv * env, JavaVM ** p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetJavaVM++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetJavaVM++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetJavaVM")
    && bda_check_no_exeception(s, "GetJavaVM")
    && bda_check_no_critical(s, "GetJavaVM")
    && bda_check_non_null(s, p1,  1, "GetJavaVM")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetJavaVM;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetJavaVM(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetStringRegion*/
static void JNICALL bda_c2j_proxy_GetStringRegion(JNIEnv * env, jstring p1, jsize p2, jsize p3, jchar * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStringRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringRegion")
    && bda_check_no_exeception(s, "GetStringRegion")
    && bda_check_no_critical(s, "GetStringRegion")
    && bda_check_non_null(s, p1,  1, "GetStringRegion")
    && bda_check_non_null(s, p4,  4, "GetStringRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetStringRegion")
    && bda_check_jstring(s, p1, 1, "GetStringRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetStringRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetStringUTFRegion*/
static void JNICALL bda_c2j_proxy_GetStringUTFRegion(JNIEnv * env, jstring p1, jsize p2, jsize p3, char * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStringUTFRegion++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringUTFRegion++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringUTFRegion")
    && bda_check_no_exeception(s, "GetStringUTFRegion")
    && bda_check_no_critical(s, "GetStringUTFRegion")
    && bda_check_non_null(s, p1,  1, "GetStringUTFRegion")
    && bda_check_non_null(s, p4,  4, "GetStringUTFRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetStringUTFRegion")
    && bda_check_jstring(s, p1, 1, "GetStringUTFRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringUTFRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetStringUTFRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

}


/* proxy for GetPrimitiveArrayCritical*/
static void * JNICALL bda_c2j_proxy_GetPrimitiveArrayCritical(JNIEnv * env, jarray p1, jboolean * p2)
{
  /* local variables */
  void * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetPrimitiveArrayCritical++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetPrimitiveArrayCritical++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetPrimitiveArrayCritical")
    && bda_check_no_exeception(s, "GetPrimitiveArrayCritical")
    && bda_check_non_null(s, p1,  1, "GetPrimitiveArrayCritical")
    && bda_check_ref_dangling(s, p1, 1, "GetPrimitiveArrayCritical")
    && bda_check_jarray(s, p1, 1, "GetPrimitiveArrayCritical")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetPrimitiveArrayCritical;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetPrimitiveArrayCritical(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    bda_enter_critical(s, (void*)result);
    if (result != NULL) {bda_resource_acquire(s, result, "GetPrimitiveArrayCritical");}
  }

  return result;
}


/* proxy for ReleasePrimitiveArrayCritical*/
static void JNICALL bda_c2j_proxy_ReleasePrimitiveArrayCritical(JNIEnv * env, jarray p1, void * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_state_find(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleasePrimitiveArrayCritical++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleasePrimitiveArrayCritical++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleasePrimitiveArrayCritical")
    && bda_check_non_null(s, p1,  1, "ReleasePrimitiveArrayCritical")
    && bda_check_non_null(s, p2,  2, "ReleasePrimitiveArrayCritical")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleasePrimitiveArrayCritical"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jarray(s, p1, 1, "ReleasePrimitiveArrayCritical"))
    && bda_check_resource_free(s, p2, "ReleasePrimitiveArrayCritical")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleasePrimitiveArrayCritical;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleasePrimitiveArrayCritical(env, p1, p2, p3);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    bda_leave_critical(s, (void*)p2);
    bda_resource_release(s, p2, "ReleasePrimitiveArrayCritical");
  }

}


/* proxy for GetStringCritical*/
static const jchar * JNICALL bda_c2j_proxy_GetStringCritical(JNIEnv * env, jstring p1, jboolean * p2)
{
  /* local variables */
  const jchar * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetStringCritical++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetStringCritical++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringCritical")
    && bda_check_no_exeception(s, "GetStringCritical")
    && bda_check_non_null(s, p1,  1, "GetStringCritical")
    && bda_check_ref_dangling(s, p1, 1, "GetStringCritical")
    && bda_check_jstring(s, p1, 1, "GetStringCritical")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringCritical;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringCritical(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    bda_enter_critical(s, (void*)result);
    if (result != NULL) {bda_resource_acquire(s, result, "GetStringCritical");}
  }

  return result;
}


/* proxy for ReleaseStringCritical*/
static void JNICALL bda_c2j_proxy_ReleaseStringCritical(JNIEnv * env, jstring p1, const jchar * p2)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_state_find(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ReleaseStringCritical++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ReleaseStringCritical++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseStringCritical")
    && bda_check_non_null(s, p1,  1, "ReleaseStringCritical")
    && bda_check_non_null(s, p2,  2, "ReleaseStringCritical")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseStringCritical"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jstring(s, p1, 1, "ReleaseStringCritical"))
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseStringCritical;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseStringCritical(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    bda_leave_critical(s, (void*)p2);
    bda_resource_release(s, p2, "ReleaseStringCritical");
  }

}


/* proxy for NewWeakGlobalRef*/
static jweak JNICALL bda_c2j_proxy_NewWeakGlobalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  jweak result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewWeakGlobalRef++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewWeakGlobalRef++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewWeakGlobalRef")
    && bda_check_no_exeception(s, "NewWeakGlobalRef")
    && bda_check_no_critical(s, "NewWeakGlobalRef")
    && bda_check_non_null(s, p1,  1, "NewWeakGlobalRef")
    && bda_check_ref_dangling(s, p1, 1, "NewWeakGlobalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewWeakGlobalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewWeakGlobalRef(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
    if (result != NULL) {
      bda_global_ref_add(result, 1);
    }
  }

  return result;
}


/* proxy for DeleteWeakGlobalRef*/
static void JNICALL bda_c2j_proxy_DeleteWeakGlobalRef(JNIEnv * env, jweak p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.DeleteWeakGlobalRef++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.DeleteWeakGlobalRef++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DeleteWeakGlobalRef")
    && bda_check_no_critical(s, "DeleteWeakGlobalRef")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "DeleteWeakGlobalRef"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jweak(s, p1, 1, "DeleteWeakGlobalRef"))
    && bda_check_jobject_ref_type(s, p1, JNIWeakGlobalRefType , 1, "DeleteWeakGlobalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DeleteWeakGlobalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->DeleteWeakGlobalRef(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   bda_global_ref_delete(p1, 1);
  }

}


/* proxy for ExceptionCheck*/
static jboolean JNICALL bda_c2j_proxy_ExceptionCheck(JNIEnv * env)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.ExceptionCheck++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.ExceptionCheck++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionCheck")
    && bda_check_no_critical(s, "ExceptionCheck")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert)&& !success){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionCheck;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ExceptionCheck(env);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for NewDirectByteBuffer*/
static jobject JNICALL bda_c2j_proxy_NewDirectByteBuffer(JNIEnv * env, void * p1, jlong p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.NewDirectByteBuffer++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.NewDirectByteBuffer++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewDirectByteBuffer")
    && bda_check_no_exeception(s, "NewDirectByteBuffer")
    && bda_check_no_critical(s, "NewDirectByteBuffer")
    && bda_check_non_null(s, p1,  1, "NewDirectByteBuffer")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewDirectByteBuffer;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewDirectByteBuffer(env, p1, p2);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewDirectByteBuffer")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);      }
   }
  }

  return result;
}


/* proxy for GetDirectBufferAddress*/
static void * JNICALL bda_c2j_proxy_GetDirectBufferAddress(JNIEnv * env, jobject p1)
{
  /* local variables */
  void * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetDirectBufferAddress++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetDirectBufferAddress++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDirectBufferAddress")
    && bda_check_no_exeception(s, "GetDirectBufferAddress")
    && bda_check_no_critical(s, "GetDirectBufferAddress")
    && bda_check_non_null(s, p1,  1, "GetDirectBufferAddress")
    && bda_check_ref_dangling(s, p1, 1, "GetDirectBufferAddress")
    && bda_check_assignable_jobject_jclass(s, p1, bda_clazz_nio_buffer, 1, "GetDirectBufferAddress")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDirectBufferAddress;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDirectBufferAddress(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetDirectBufferCapacity*/
static jlong JNICALL bda_c2j_proxy_GetDirectBufferCapacity(JNIEnv * env, jobject p1)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetDirectBufferCapacity++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetDirectBufferCapacity++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDirectBufferCapacity")
    && bda_check_no_exeception(s, "GetDirectBufferCapacity")
    && bda_check_no_critical(s, "GetDirectBufferCapacity")
    && bda_check_non_null(s, p1,  1, "GetDirectBufferCapacity")
    && bda_check_ref_dangling(s, p1, 1, "GetDirectBufferCapacity")
    && bda_check_assignable_jobject_jclass(s, p1, bda_clazz_nio_buffer, 1, "GetDirectBufferCapacity")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDirectBufferCapacity;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDirectBufferCapacity(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}


/* proxy for GetObjectRefType*/
static jobjectRefType JNICALL bda_c2j_proxy_GetObjectRefType(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobjectRefType result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_c2j_info c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    bda_c2j_count.GetObjectRefType++;
    if (s->mode == USR_NATIVE) {bda_c2j_count_user.GetObjectRefType++;}
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (agent_options.jniassert && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectRefType")
    && bda_check_no_exeception(s, "GetObjectRefType")
    && bda_check_no_critical(s, "GetObjectRefType")
    && bda_check_non_null(s, p1,  1, "GetObjectRefType")
    && bda_check_ref_dangling(s, p1, 1, "GetObjectRefType")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jniassert )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the c2j_info structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectRefType;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectRefType(env, p1);
  L_RETURN:

  /* Pop the c2j_info structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jniassert && (s->mode != JVM)) {
  }

  return result;
}

void bda_c2j_proxy_install(jvmtiEnv *jvmti)
{
  jvmtiError err;
  err = (*jvmti)->GetJNIFunctionTable(jvmti, &proxy_jni_funcs);
  assert(err == JVMTI_ERROR_NONE);
  proxy_jni_funcs->GetVersion = bda_c2j_proxy_GetVersion;
  proxy_jni_funcs->DefineClass = bda_c2j_proxy_DefineClass;
  proxy_jni_funcs->FindClass = bda_c2j_proxy_FindClass;
  proxy_jni_funcs->FromReflectedMethod = bda_c2j_proxy_FromReflectedMethod;
  proxy_jni_funcs->FromReflectedField = bda_c2j_proxy_FromReflectedField;
  proxy_jni_funcs->ToReflectedMethod = bda_c2j_proxy_ToReflectedMethod;
  proxy_jni_funcs->GetSuperclass = bda_c2j_proxy_GetSuperclass;
  proxy_jni_funcs->IsAssignableFrom = bda_c2j_proxy_IsAssignableFrom;
  proxy_jni_funcs->ToReflectedField = bda_c2j_proxy_ToReflectedField;
  proxy_jni_funcs->Throw = bda_c2j_proxy_Throw;
  proxy_jni_funcs->ThrowNew = bda_c2j_proxy_ThrowNew;
  proxy_jni_funcs->ExceptionOccurred = bda_c2j_proxy_ExceptionOccurred;
  proxy_jni_funcs->ExceptionDescribe = bda_c2j_proxy_ExceptionDescribe;
  proxy_jni_funcs->ExceptionClear = bda_c2j_proxy_ExceptionClear;
  proxy_jni_funcs->FatalError = bda_c2j_proxy_FatalError;
  proxy_jni_funcs->PushLocalFrame = bda_c2j_proxy_PushLocalFrame;
  proxy_jni_funcs->PopLocalFrame = bda_c2j_proxy_PopLocalFrame;
  proxy_jni_funcs->NewGlobalRef = bda_c2j_proxy_NewGlobalRef;
  proxy_jni_funcs->DeleteGlobalRef = bda_c2j_proxy_DeleteGlobalRef;
  proxy_jni_funcs->DeleteLocalRef = bda_c2j_proxy_DeleteLocalRef;
  proxy_jni_funcs->IsSameObject = bda_c2j_proxy_IsSameObject;
  proxy_jni_funcs->NewLocalRef = bda_c2j_proxy_NewLocalRef;
  proxy_jni_funcs->EnsureLocalCapacity = bda_c2j_proxy_EnsureLocalCapacity;
  proxy_jni_funcs->AllocObject = bda_c2j_proxy_AllocObject;
  proxy_jni_funcs->NewObject = bda_c2j_proxy_NewObject;
  proxy_jni_funcs->NewObjectV = bda_c2j_proxy_NewObjectV;
  proxy_jni_funcs->NewObjectA = bda_c2j_proxy_NewObjectA;
  proxy_jni_funcs->GetObjectClass = bda_c2j_proxy_GetObjectClass;
  proxy_jni_funcs->IsInstanceOf = bda_c2j_proxy_IsInstanceOf;
  proxy_jni_funcs->GetMethodID = bda_c2j_proxy_GetMethodID;
  proxy_jni_funcs->CallObjectMethod = bda_c2j_proxy_CallObjectMethod;
  proxy_jni_funcs->CallObjectMethodV = bda_c2j_proxy_CallObjectMethodV;
  proxy_jni_funcs->CallObjectMethodA = bda_c2j_proxy_CallObjectMethodA;
  proxy_jni_funcs->CallBooleanMethod = bda_c2j_proxy_CallBooleanMethod;
  proxy_jni_funcs->CallBooleanMethodV = bda_c2j_proxy_CallBooleanMethodV;
  proxy_jni_funcs->CallBooleanMethodA = bda_c2j_proxy_CallBooleanMethodA;
  proxy_jni_funcs->CallByteMethod = bda_c2j_proxy_CallByteMethod;
  proxy_jni_funcs->CallByteMethodV = bda_c2j_proxy_CallByteMethodV;
  proxy_jni_funcs->CallByteMethodA = bda_c2j_proxy_CallByteMethodA;
  proxy_jni_funcs->CallCharMethod = bda_c2j_proxy_CallCharMethod;
  proxy_jni_funcs->CallCharMethodV = bda_c2j_proxy_CallCharMethodV;
  proxy_jni_funcs->CallCharMethodA = bda_c2j_proxy_CallCharMethodA;
  proxy_jni_funcs->CallShortMethod = bda_c2j_proxy_CallShortMethod;
  proxy_jni_funcs->CallShortMethodV = bda_c2j_proxy_CallShortMethodV;
  proxy_jni_funcs->CallShortMethodA = bda_c2j_proxy_CallShortMethodA;
  proxy_jni_funcs->CallIntMethod = bda_c2j_proxy_CallIntMethod;
  proxy_jni_funcs->CallIntMethodV = bda_c2j_proxy_CallIntMethodV;
  proxy_jni_funcs->CallIntMethodA = bda_c2j_proxy_CallIntMethodA;
  proxy_jni_funcs->CallLongMethod = bda_c2j_proxy_CallLongMethod;
  proxy_jni_funcs->CallLongMethodV = bda_c2j_proxy_CallLongMethodV;
  proxy_jni_funcs->CallLongMethodA = bda_c2j_proxy_CallLongMethodA;
  proxy_jni_funcs->CallFloatMethod = bda_c2j_proxy_CallFloatMethod;
  proxy_jni_funcs->CallFloatMethodV = bda_c2j_proxy_CallFloatMethodV;
  proxy_jni_funcs->CallFloatMethodA = bda_c2j_proxy_CallFloatMethodA;
  proxy_jni_funcs->CallDoubleMethod = bda_c2j_proxy_CallDoubleMethod;
  proxy_jni_funcs->CallDoubleMethodV = bda_c2j_proxy_CallDoubleMethodV;
  proxy_jni_funcs->CallDoubleMethodA = bda_c2j_proxy_CallDoubleMethodA;
  proxy_jni_funcs->CallVoidMethod = bda_c2j_proxy_CallVoidMethod;
  proxy_jni_funcs->CallVoidMethodV = bda_c2j_proxy_CallVoidMethodV;
  proxy_jni_funcs->CallVoidMethodA = bda_c2j_proxy_CallVoidMethodA;
  proxy_jni_funcs->CallNonvirtualObjectMethod = bda_c2j_proxy_CallNonvirtualObjectMethod;
  proxy_jni_funcs->CallNonvirtualObjectMethodV = bda_c2j_proxy_CallNonvirtualObjectMethodV;
  proxy_jni_funcs->CallNonvirtualObjectMethodA = bda_c2j_proxy_CallNonvirtualObjectMethodA;
  proxy_jni_funcs->CallNonvirtualBooleanMethod = bda_c2j_proxy_CallNonvirtualBooleanMethod;
  proxy_jni_funcs->CallNonvirtualBooleanMethodV = bda_c2j_proxy_CallNonvirtualBooleanMethodV;
  proxy_jni_funcs->CallNonvirtualBooleanMethodA = bda_c2j_proxy_CallNonvirtualBooleanMethodA;
  proxy_jni_funcs->CallNonvirtualByteMethod = bda_c2j_proxy_CallNonvirtualByteMethod;
  proxy_jni_funcs->CallNonvirtualByteMethodV = bda_c2j_proxy_CallNonvirtualByteMethodV;
  proxy_jni_funcs->CallNonvirtualByteMethodA = bda_c2j_proxy_CallNonvirtualByteMethodA;
  proxy_jni_funcs->CallNonvirtualCharMethod = bda_c2j_proxy_CallNonvirtualCharMethod;
  proxy_jni_funcs->CallNonvirtualCharMethodV = bda_c2j_proxy_CallNonvirtualCharMethodV;
  proxy_jni_funcs->CallNonvirtualCharMethodA = bda_c2j_proxy_CallNonvirtualCharMethodA;
  proxy_jni_funcs->CallNonvirtualShortMethod = bda_c2j_proxy_CallNonvirtualShortMethod;
  proxy_jni_funcs->CallNonvirtualShortMethodV = bda_c2j_proxy_CallNonvirtualShortMethodV;
  proxy_jni_funcs->CallNonvirtualShortMethodA = bda_c2j_proxy_CallNonvirtualShortMethodA;
  proxy_jni_funcs->CallNonvirtualIntMethod = bda_c2j_proxy_CallNonvirtualIntMethod;
  proxy_jni_funcs->CallNonvirtualIntMethodV = bda_c2j_proxy_CallNonvirtualIntMethodV;
  proxy_jni_funcs->CallNonvirtualIntMethodA = bda_c2j_proxy_CallNonvirtualIntMethodA;
  proxy_jni_funcs->CallNonvirtualLongMethod = bda_c2j_proxy_CallNonvirtualLongMethod;
  proxy_jni_funcs->CallNonvirtualLongMethodV = bda_c2j_proxy_CallNonvirtualLongMethodV;
  proxy_jni_funcs->CallNonvirtualLongMethodA = bda_c2j_proxy_CallNonvirtualLongMethodA;
  proxy_jni_funcs->CallNonvirtualFloatMethod = bda_c2j_proxy_CallNonvirtualFloatMethod;
  proxy_jni_funcs->CallNonvirtualFloatMethodV = bda_c2j_proxy_CallNonvirtualFloatMethodV;
  proxy_jni_funcs->CallNonvirtualFloatMethodA = bda_c2j_proxy_CallNonvirtualFloatMethodA;
  proxy_jni_funcs->CallNonvirtualDoubleMethod = bda_c2j_proxy_CallNonvirtualDoubleMethod;
  proxy_jni_funcs->CallNonvirtualDoubleMethodV = bda_c2j_proxy_CallNonvirtualDoubleMethodV;
  proxy_jni_funcs->CallNonvirtualDoubleMethodA = bda_c2j_proxy_CallNonvirtualDoubleMethodA;
  proxy_jni_funcs->CallNonvirtualVoidMethod = bda_c2j_proxy_CallNonvirtualVoidMethod;
  proxy_jni_funcs->CallNonvirtualVoidMethodV = bda_c2j_proxy_CallNonvirtualVoidMethodV;
  proxy_jni_funcs->CallNonvirtualVoidMethodA = bda_c2j_proxy_CallNonvirtualVoidMethodA;
  proxy_jni_funcs->GetFieldID = bda_c2j_proxy_GetFieldID;
  proxy_jni_funcs->GetObjectField = bda_c2j_proxy_GetObjectField;
  proxy_jni_funcs->GetBooleanField = bda_c2j_proxy_GetBooleanField;
  proxy_jni_funcs->GetByteField = bda_c2j_proxy_GetByteField;
  proxy_jni_funcs->GetCharField = bda_c2j_proxy_GetCharField;
  proxy_jni_funcs->GetShortField = bda_c2j_proxy_GetShortField;
  proxy_jni_funcs->GetIntField = bda_c2j_proxy_GetIntField;
  proxy_jni_funcs->GetLongField = bda_c2j_proxy_GetLongField;
  proxy_jni_funcs->GetFloatField = bda_c2j_proxy_GetFloatField;
  proxy_jni_funcs->GetDoubleField = bda_c2j_proxy_GetDoubleField;
  proxy_jni_funcs->SetObjectField = bda_c2j_proxy_SetObjectField;
  proxy_jni_funcs->SetBooleanField = bda_c2j_proxy_SetBooleanField;
  proxy_jni_funcs->SetByteField = bda_c2j_proxy_SetByteField;
  proxy_jni_funcs->SetCharField = bda_c2j_proxy_SetCharField;
  proxy_jni_funcs->SetShortField = bda_c2j_proxy_SetShortField;
  proxy_jni_funcs->SetIntField = bda_c2j_proxy_SetIntField;
  proxy_jni_funcs->SetLongField = bda_c2j_proxy_SetLongField;
  proxy_jni_funcs->SetFloatField = bda_c2j_proxy_SetFloatField;
  proxy_jni_funcs->SetDoubleField = bda_c2j_proxy_SetDoubleField;
  proxy_jni_funcs->GetStaticMethodID = bda_c2j_proxy_GetStaticMethodID;
  proxy_jni_funcs->CallStaticObjectMethod = bda_c2j_proxy_CallStaticObjectMethod;
  proxy_jni_funcs->CallStaticObjectMethodV = bda_c2j_proxy_CallStaticObjectMethodV;
  proxy_jni_funcs->CallStaticObjectMethodA = bda_c2j_proxy_CallStaticObjectMethodA;
  proxy_jni_funcs->CallStaticBooleanMethod = bda_c2j_proxy_CallStaticBooleanMethod;
  proxy_jni_funcs->CallStaticBooleanMethodV = bda_c2j_proxy_CallStaticBooleanMethodV;
  proxy_jni_funcs->CallStaticBooleanMethodA = bda_c2j_proxy_CallStaticBooleanMethodA;
  proxy_jni_funcs->CallStaticByteMethod = bda_c2j_proxy_CallStaticByteMethod;
  proxy_jni_funcs->CallStaticByteMethodV = bda_c2j_proxy_CallStaticByteMethodV;
  proxy_jni_funcs->CallStaticByteMethodA = bda_c2j_proxy_CallStaticByteMethodA;
  proxy_jni_funcs->CallStaticCharMethod = bda_c2j_proxy_CallStaticCharMethod;
  proxy_jni_funcs->CallStaticCharMethodV = bda_c2j_proxy_CallStaticCharMethodV;
  proxy_jni_funcs->CallStaticCharMethodA = bda_c2j_proxy_CallStaticCharMethodA;
  proxy_jni_funcs->CallStaticShortMethod = bda_c2j_proxy_CallStaticShortMethod;
  proxy_jni_funcs->CallStaticShortMethodV = bda_c2j_proxy_CallStaticShortMethodV;
  proxy_jni_funcs->CallStaticShortMethodA = bda_c2j_proxy_CallStaticShortMethodA;
  proxy_jni_funcs->CallStaticIntMethod = bda_c2j_proxy_CallStaticIntMethod;
  proxy_jni_funcs->CallStaticIntMethodV = bda_c2j_proxy_CallStaticIntMethodV;
  proxy_jni_funcs->CallStaticIntMethodA = bda_c2j_proxy_CallStaticIntMethodA;
  proxy_jni_funcs->CallStaticLongMethod = bda_c2j_proxy_CallStaticLongMethod;
  proxy_jni_funcs->CallStaticLongMethodV = bda_c2j_proxy_CallStaticLongMethodV;
  proxy_jni_funcs->CallStaticLongMethodA = bda_c2j_proxy_CallStaticLongMethodA;
  proxy_jni_funcs->CallStaticFloatMethod = bda_c2j_proxy_CallStaticFloatMethod;
  proxy_jni_funcs->CallStaticFloatMethodV = bda_c2j_proxy_CallStaticFloatMethodV;
  proxy_jni_funcs->CallStaticFloatMethodA = bda_c2j_proxy_CallStaticFloatMethodA;
  proxy_jni_funcs->CallStaticDoubleMethod = bda_c2j_proxy_CallStaticDoubleMethod;
  proxy_jni_funcs->CallStaticDoubleMethodV = bda_c2j_proxy_CallStaticDoubleMethodV;
  proxy_jni_funcs->CallStaticDoubleMethodA = bda_c2j_proxy_CallStaticDoubleMethodA;
  proxy_jni_funcs->CallStaticVoidMethod = bda_c2j_proxy_CallStaticVoidMethod;
  proxy_jni_funcs->CallStaticVoidMethodV = bda_c2j_proxy_CallStaticVoidMethodV;
  proxy_jni_funcs->CallStaticVoidMethodA = bda_c2j_proxy_CallStaticVoidMethodA;
  proxy_jni_funcs->GetStaticFieldID = bda_c2j_proxy_GetStaticFieldID;
  proxy_jni_funcs->GetStaticObjectField = bda_c2j_proxy_GetStaticObjectField;
  proxy_jni_funcs->GetStaticBooleanField = bda_c2j_proxy_GetStaticBooleanField;
  proxy_jni_funcs->GetStaticByteField = bda_c2j_proxy_GetStaticByteField;
  proxy_jni_funcs->GetStaticCharField = bda_c2j_proxy_GetStaticCharField;
  proxy_jni_funcs->GetStaticShortField = bda_c2j_proxy_GetStaticShortField;
  proxy_jni_funcs->GetStaticIntField = bda_c2j_proxy_GetStaticIntField;
  proxy_jni_funcs->GetStaticLongField = bda_c2j_proxy_GetStaticLongField;
  proxy_jni_funcs->GetStaticFloatField = bda_c2j_proxy_GetStaticFloatField;
  proxy_jni_funcs->GetStaticDoubleField = bda_c2j_proxy_GetStaticDoubleField;
  proxy_jni_funcs->SetStaticObjectField = bda_c2j_proxy_SetStaticObjectField;
  proxy_jni_funcs->SetStaticBooleanField = bda_c2j_proxy_SetStaticBooleanField;
  proxy_jni_funcs->SetStaticByteField = bda_c2j_proxy_SetStaticByteField;
  proxy_jni_funcs->SetStaticCharField = bda_c2j_proxy_SetStaticCharField;
  proxy_jni_funcs->SetStaticShortField = bda_c2j_proxy_SetStaticShortField;
  proxy_jni_funcs->SetStaticIntField = bda_c2j_proxy_SetStaticIntField;
  proxy_jni_funcs->SetStaticLongField = bda_c2j_proxy_SetStaticLongField;
  proxy_jni_funcs->SetStaticFloatField = bda_c2j_proxy_SetStaticFloatField;
  proxy_jni_funcs->SetStaticDoubleField = bda_c2j_proxy_SetStaticDoubleField;
  proxy_jni_funcs->NewString = bda_c2j_proxy_NewString;
  proxy_jni_funcs->GetStringLength = bda_c2j_proxy_GetStringLength;
  proxy_jni_funcs->GetStringChars = bda_c2j_proxy_GetStringChars;
  proxy_jni_funcs->ReleaseStringChars = bda_c2j_proxy_ReleaseStringChars;
  proxy_jni_funcs->NewStringUTF = bda_c2j_proxy_NewStringUTF;
  proxy_jni_funcs->GetStringUTFLength = bda_c2j_proxy_GetStringUTFLength;
  proxy_jni_funcs->GetStringUTFChars = bda_c2j_proxy_GetStringUTFChars;
  proxy_jni_funcs->ReleaseStringUTFChars = bda_c2j_proxy_ReleaseStringUTFChars;
  proxy_jni_funcs->GetArrayLength = bda_c2j_proxy_GetArrayLength;
  proxy_jni_funcs->NewObjectArray = bda_c2j_proxy_NewObjectArray;
  proxy_jni_funcs->GetObjectArrayElement = bda_c2j_proxy_GetObjectArrayElement;
  proxy_jni_funcs->SetObjectArrayElement = bda_c2j_proxy_SetObjectArrayElement;
  proxy_jni_funcs->NewBooleanArray = bda_c2j_proxy_NewBooleanArray;
  proxy_jni_funcs->NewByteArray = bda_c2j_proxy_NewByteArray;
  proxy_jni_funcs->NewCharArray = bda_c2j_proxy_NewCharArray;
  proxy_jni_funcs->NewShortArray = bda_c2j_proxy_NewShortArray;
  proxy_jni_funcs->NewIntArray = bda_c2j_proxy_NewIntArray;
  proxy_jni_funcs->NewLongArray = bda_c2j_proxy_NewLongArray;
  proxy_jni_funcs->NewFloatArray = bda_c2j_proxy_NewFloatArray;
  proxy_jni_funcs->NewDoubleArray = bda_c2j_proxy_NewDoubleArray;
  proxy_jni_funcs->GetBooleanArrayElements = bda_c2j_proxy_GetBooleanArrayElements;
  proxy_jni_funcs->GetByteArrayElements = bda_c2j_proxy_GetByteArrayElements;
  proxy_jni_funcs->GetCharArrayElements = bda_c2j_proxy_GetCharArrayElements;
  proxy_jni_funcs->GetShortArrayElements = bda_c2j_proxy_GetShortArrayElements;
  proxy_jni_funcs->GetIntArrayElements = bda_c2j_proxy_GetIntArrayElements;
  proxy_jni_funcs->GetLongArrayElements = bda_c2j_proxy_GetLongArrayElements;
  proxy_jni_funcs->GetFloatArrayElements = bda_c2j_proxy_GetFloatArrayElements;
  proxy_jni_funcs->GetDoubleArrayElements = bda_c2j_proxy_GetDoubleArrayElements;
  proxy_jni_funcs->ReleaseBooleanArrayElements = bda_c2j_proxy_ReleaseBooleanArrayElements;
  proxy_jni_funcs->ReleaseByteArrayElements = bda_c2j_proxy_ReleaseByteArrayElements;
  proxy_jni_funcs->ReleaseCharArrayElements = bda_c2j_proxy_ReleaseCharArrayElements;
  proxy_jni_funcs->ReleaseShortArrayElements = bda_c2j_proxy_ReleaseShortArrayElements;
  proxy_jni_funcs->ReleaseIntArrayElements = bda_c2j_proxy_ReleaseIntArrayElements;
  proxy_jni_funcs->ReleaseLongArrayElements = bda_c2j_proxy_ReleaseLongArrayElements;
  proxy_jni_funcs->ReleaseFloatArrayElements = bda_c2j_proxy_ReleaseFloatArrayElements;
  proxy_jni_funcs->ReleaseDoubleArrayElements = bda_c2j_proxy_ReleaseDoubleArrayElements;
  proxy_jni_funcs->GetBooleanArrayRegion = bda_c2j_proxy_GetBooleanArrayRegion;
  proxy_jni_funcs->GetByteArrayRegion = bda_c2j_proxy_GetByteArrayRegion;
  proxy_jni_funcs->GetCharArrayRegion = bda_c2j_proxy_GetCharArrayRegion;
  proxy_jni_funcs->GetShortArrayRegion = bda_c2j_proxy_GetShortArrayRegion;
  proxy_jni_funcs->GetIntArrayRegion = bda_c2j_proxy_GetIntArrayRegion;
  proxy_jni_funcs->GetLongArrayRegion = bda_c2j_proxy_GetLongArrayRegion;
  proxy_jni_funcs->GetFloatArrayRegion = bda_c2j_proxy_GetFloatArrayRegion;
  proxy_jni_funcs->GetDoubleArrayRegion = bda_c2j_proxy_GetDoubleArrayRegion;
  proxy_jni_funcs->SetBooleanArrayRegion = bda_c2j_proxy_SetBooleanArrayRegion;
  proxy_jni_funcs->SetByteArrayRegion = bda_c2j_proxy_SetByteArrayRegion;
  proxy_jni_funcs->SetCharArrayRegion = bda_c2j_proxy_SetCharArrayRegion;
  proxy_jni_funcs->SetShortArrayRegion = bda_c2j_proxy_SetShortArrayRegion;
  proxy_jni_funcs->SetIntArrayRegion = bda_c2j_proxy_SetIntArrayRegion;
  proxy_jni_funcs->SetLongArrayRegion = bda_c2j_proxy_SetLongArrayRegion;
  proxy_jni_funcs->SetFloatArrayRegion = bda_c2j_proxy_SetFloatArrayRegion;
  proxy_jni_funcs->SetDoubleArrayRegion = bda_c2j_proxy_SetDoubleArrayRegion;
  proxy_jni_funcs->RegisterNatives = bda_c2j_proxy_RegisterNatives;
  proxy_jni_funcs->UnregisterNatives = bda_c2j_proxy_UnregisterNatives;
  proxy_jni_funcs->MonitorEnter = bda_c2j_proxy_MonitorEnter;
  proxy_jni_funcs->MonitorExit = bda_c2j_proxy_MonitorExit;
  proxy_jni_funcs->GetJavaVM = bda_c2j_proxy_GetJavaVM;
  proxy_jni_funcs->GetStringRegion = bda_c2j_proxy_GetStringRegion;
  proxy_jni_funcs->GetStringUTFRegion = bda_c2j_proxy_GetStringUTFRegion;
  proxy_jni_funcs->GetPrimitiveArrayCritical = bda_c2j_proxy_GetPrimitiveArrayCritical;
  proxy_jni_funcs->ReleasePrimitiveArrayCritical = bda_c2j_proxy_ReleasePrimitiveArrayCritical;
  proxy_jni_funcs->GetStringCritical = bda_c2j_proxy_GetStringCritical;
  proxy_jni_funcs->ReleaseStringCritical = bda_c2j_proxy_ReleaseStringCritical;
  proxy_jni_funcs->NewWeakGlobalRef = bda_c2j_proxy_NewWeakGlobalRef;
  proxy_jni_funcs->DeleteWeakGlobalRef = bda_c2j_proxy_DeleteWeakGlobalRef;
  proxy_jni_funcs->ExceptionCheck = bda_c2j_proxy_ExceptionCheck;
  proxy_jni_funcs->NewDirectByteBuffer = bda_c2j_proxy_NewDirectByteBuffer;
  proxy_jni_funcs->GetDirectBufferAddress = bda_c2j_proxy_GetDirectBufferAddress;
  proxy_jni_funcs->GetDirectBufferCapacity = bda_c2j_proxy_GetDirectBufferCapacity;
  proxy_jni_funcs->GetObjectRefType = bda_c2j_proxy_GetObjectRefType;
  err = (*jvmti)->SetJNIFunctionTable(jvmti, proxy_jni_funcs);
  assert(err == JVMTI_ERROR_NONE);
  memset(&bda_c2j_count, 0, sizeof(bda_c2j_count));
  memset(&bda_c2j_count_user, 0, sizeof(bda_c2j_count_user));
}
void bda_c2j_proxy_dump_stat()
{
  int sum = 0;
  int sum_user = 0;
  int count, count_user;

  count = bda_c2j_count.GetVersion;
  count_user = bda_c2j_count_user.GetVersion;
  printf("%7u %7u %s\n", count, count_user, "GetVersion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.DefineClass;
  count_user = bda_c2j_count_user.DefineClass;
  printf("%7u %7u %s\n", count, count_user, "DefineClass");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.FindClass;
  count_user = bda_c2j_count_user.FindClass;
  printf("%7u %7u %s\n", count, count_user, "FindClass");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.FromReflectedMethod;
  count_user = bda_c2j_count_user.FromReflectedMethod;
  printf("%7u %7u %s\n", count, count_user, "FromReflectedMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.FromReflectedField;
  count_user = bda_c2j_count_user.FromReflectedField;
  printf("%7u %7u %s\n", count, count_user, "FromReflectedField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ToReflectedMethod;
  count_user = bda_c2j_count_user.ToReflectedMethod;
  printf("%7u %7u %s\n", count, count_user, "ToReflectedMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetSuperclass;
  count_user = bda_c2j_count_user.GetSuperclass;
  printf("%7u %7u %s\n", count, count_user, "GetSuperclass");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.IsAssignableFrom;
  count_user = bda_c2j_count_user.IsAssignableFrom;
  printf("%7u %7u %s\n", count, count_user, "IsAssignableFrom");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ToReflectedField;
  count_user = bda_c2j_count_user.ToReflectedField;
  printf("%7u %7u %s\n", count, count_user, "ToReflectedField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.Throw;
  count_user = bda_c2j_count_user.Throw;
  printf("%7u %7u %s\n", count, count_user, "Throw");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ThrowNew;
  count_user = bda_c2j_count_user.ThrowNew;
  printf("%7u %7u %s\n", count, count_user, "ThrowNew");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ExceptionOccurred;
  count_user = bda_c2j_count_user.ExceptionOccurred;
  printf("%7u %7u %s\n", count, count_user, "ExceptionOccurred");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ExceptionDescribe;
  count_user = bda_c2j_count_user.ExceptionDescribe;
  printf("%7u %7u %s\n", count, count_user, "ExceptionDescribe");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ExceptionClear;
  count_user = bda_c2j_count_user.ExceptionClear;
  printf("%7u %7u %s\n", count, count_user, "ExceptionClear");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.FatalError;
  count_user = bda_c2j_count_user.FatalError;
  printf("%7u %7u %s\n", count, count_user, "FatalError");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.PushLocalFrame;
  count_user = bda_c2j_count_user.PushLocalFrame;
  printf("%7u %7u %s\n", count, count_user, "PushLocalFrame");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.PopLocalFrame;
  count_user = bda_c2j_count_user.PopLocalFrame;
  printf("%7u %7u %s\n", count, count_user, "PopLocalFrame");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewGlobalRef;
  count_user = bda_c2j_count_user.NewGlobalRef;
  printf("%7u %7u %s\n", count, count_user, "NewGlobalRef");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.DeleteGlobalRef;
  count_user = bda_c2j_count_user.DeleteGlobalRef;
  printf("%7u %7u %s\n", count, count_user, "DeleteGlobalRef");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.DeleteLocalRef;
  count_user = bda_c2j_count_user.DeleteLocalRef;
  printf("%7u %7u %s\n", count, count_user, "DeleteLocalRef");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.IsSameObject;
  count_user = bda_c2j_count_user.IsSameObject;
  printf("%7u %7u %s\n", count, count_user, "IsSameObject");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewLocalRef;
  count_user = bda_c2j_count_user.NewLocalRef;
  printf("%7u %7u %s\n", count, count_user, "NewLocalRef");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.EnsureLocalCapacity;
  count_user = bda_c2j_count_user.EnsureLocalCapacity;
  printf("%7u %7u %s\n", count, count_user, "EnsureLocalCapacity");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.AllocObject;
  count_user = bda_c2j_count_user.AllocObject;
  printf("%7u %7u %s\n", count, count_user, "AllocObject");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewObject;
  count_user = bda_c2j_count_user.NewObject;
  printf("%7u %7u %s\n", count, count_user, "NewObject");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewObjectV;
  count_user = bda_c2j_count_user.NewObjectV;
  printf("%7u %7u %s\n", count, count_user, "NewObjectV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewObjectA;
  count_user = bda_c2j_count_user.NewObjectA;
  printf("%7u %7u %s\n", count, count_user, "NewObjectA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetObjectClass;
  count_user = bda_c2j_count_user.GetObjectClass;
  printf("%7u %7u %s\n", count, count_user, "GetObjectClass");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.IsInstanceOf;
  count_user = bda_c2j_count_user.IsInstanceOf;
  printf("%7u %7u %s\n", count, count_user, "IsInstanceOf");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetMethodID;
  count_user = bda_c2j_count_user.GetMethodID;
  printf("%7u %7u %s\n", count, count_user, "GetMethodID");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallObjectMethod;
  count_user = bda_c2j_count_user.CallObjectMethod;
  printf("%7u %7u %s\n", count, count_user, "CallObjectMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallObjectMethodV;
  count_user = bda_c2j_count_user.CallObjectMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallObjectMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallObjectMethodA;
  count_user = bda_c2j_count_user.CallObjectMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallObjectMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallBooleanMethod;
  count_user = bda_c2j_count_user.CallBooleanMethod;
  printf("%7u %7u %s\n", count, count_user, "CallBooleanMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallBooleanMethodV;
  count_user = bda_c2j_count_user.CallBooleanMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallBooleanMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallBooleanMethodA;
  count_user = bda_c2j_count_user.CallBooleanMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallBooleanMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallByteMethod;
  count_user = bda_c2j_count_user.CallByteMethod;
  printf("%7u %7u %s\n", count, count_user, "CallByteMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallByteMethodV;
  count_user = bda_c2j_count_user.CallByteMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallByteMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallByteMethodA;
  count_user = bda_c2j_count_user.CallByteMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallByteMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallCharMethod;
  count_user = bda_c2j_count_user.CallCharMethod;
  printf("%7u %7u %s\n", count, count_user, "CallCharMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallCharMethodV;
  count_user = bda_c2j_count_user.CallCharMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallCharMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallCharMethodA;
  count_user = bda_c2j_count_user.CallCharMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallCharMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallShortMethod;
  count_user = bda_c2j_count_user.CallShortMethod;
  printf("%7u %7u %s\n", count, count_user, "CallShortMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallShortMethodV;
  count_user = bda_c2j_count_user.CallShortMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallShortMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallShortMethodA;
  count_user = bda_c2j_count_user.CallShortMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallShortMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallIntMethod;
  count_user = bda_c2j_count_user.CallIntMethod;
  printf("%7u %7u %s\n", count, count_user, "CallIntMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallIntMethodV;
  count_user = bda_c2j_count_user.CallIntMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallIntMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallIntMethodA;
  count_user = bda_c2j_count_user.CallIntMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallIntMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallLongMethod;
  count_user = bda_c2j_count_user.CallLongMethod;
  printf("%7u %7u %s\n", count, count_user, "CallLongMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallLongMethodV;
  count_user = bda_c2j_count_user.CallLongMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallLongMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallLongMethodA;
  count_user = bda_c2j_count_user.CallLongMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallLongMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallFloatMethod;
  count_user = bda_c2j_count_user.CallFloatMethod;
  printf("%7u %7u %s\n", count, count_user, "CallFloatMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallFloatMethodV;
  count_user = bda_c2j_count_user.CallFloatMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallFloatMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallFloatMethodA;
  count_user = bda_c2j_count_user.CallFloatMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallFloatMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallDoubleMethod;
  count_user = bda_c2j_count_user.CallDoubleMethod;
  printf("%7u %7u %s\n", count, count_user, "CallDoubleMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallDoubleMethodV;
  count_user = bda_c2j_count_user.CallDoubleMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallDoubleMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallDoubleMethodA;
  count_user = bda_c2j_count_user.CallDoubleMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallDoubleMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallVoidMethod;
  count_user = bda_c2j_count_user.CallVoidMethod;
  printf("%7u %7u %s\n", count, count_user, "CallVoidMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallVoidMethodV;
  count_user = bda_c2j_count_user.CallVoidMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallVoidMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallVoidMethodA;
  count_user = bda_c2j_count_user.CallVoidMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallVoidMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualObjectMethod;
  count_user = bda_c2j_count_user.CallNonvirtualObjectMethod;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualObjectMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualObjectMethodV;
  count_user = bda_c2j_count_user.CallNonvirtualObjectMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualObjectMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualObjectMethodA;
  count_user = bda_c2j_count_user.CallNonvirtualObjectMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualObjectMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualBooleanMethod;
  count_user = bda_c2j_count_user.CallNonvirtualBooleanMethod;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualBooleanMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualBooleanMethodV;
  count_user = bda_c2j_count_user.CallNonvirtualBooleanMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualBooleanMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualBooleanMethodA;
  count_user = bda_c2j_count_user.CallNonvirtualBooleanMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualBooleanMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualByteMethod;
  count_user = bda_c2j_count_user.CallNonvirtualByteMethod;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualByteMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualByteMethodV;
  count_user = bda_c2j_count_user.CallNonvirtualByteMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualByteMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualByteMethodA;
  count_user = bda_c2j_count_user.CallNonvirtualByteMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualByteMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualCharMethod;
  count_user = bda_c2j_count_user.CallNonvirtualCharMethod;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualCharMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualCharMethodV;
  count_user = bda_c2j_count_user.CallNonvirtualCharMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualCharMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualCharMethodA;
  count_user = bda_c2j_count_user.CallNonvirtualCharMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualCharMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualShortMethod;
  count_user = bda_c2j_count_user.CallNonvirtualShortMethod;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualShortMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualShortMethodV;
  count_user = bda_c2j_count_user.CallNonvirtualShortMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualShortMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualShortMethodA;
  count_user = bda_c2j_count_user.CallNonvirtualShortMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualShortMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualIntMethod;
  count_user = bda_c2j_count_user.CallNonvirtualIntMethod;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualIntMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualIntMethodV;
  count_user = bda_c2j_count_user.CallNonvirtualIntMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualIntMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualIntMethodA;
  count_user = bda_c2j_count_user.CallNonvirtualIntMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualIntMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualLongMethod;
  count_user = bda_c2j_count_user.CallNonvirtualLongMethod;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualLongMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualLongMethodV;
  count_user = bda_c2j_count_user.CallNonvirtualLongMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualLongMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualLongMethodA;
  count_user = bda_c2j_count_user.CallNonvirtualLongMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualLongMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualFloatMethod;
  count_user = bda_c2j_count_user.CallNonvirtualFloatMethod;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualFloatMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualFloatMethodV;
  count_user = bda_c2j_count_user.CallNonvirtualFloatMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualFloatMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualFloatMethodA;
  count_user = bda_c2j_count_user.CallNonvirtualFloatMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualFloatMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualDoubleMethod;
  count_user = bda_c2j_count_user.CallNonvirtualDoubleMethod;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualDoubleMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualDoubleMethodV;
  count_user = bda_c2j_count_user.CallNonvirtualDoubleMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualDoubleMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualDoubleMethodA;
  count_user = bda_c2j_count_user.CallNonvirtualDoubleMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualDoubleMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualVoidMethod;
  count_user = bda_c2j_count_user.CallNonvirtualVoidMethod;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualVoidMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualVoidMethodV;
  count_user = bda_c2j_count_user.CallNonvirtualVoidMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualVoidMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallNonvirtualVoidMethodA;
  count_user = bda_c2j_count_user.CallNonvirtualVoidMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallNonvirtualVoidMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetFieldID;
  count_user = bda_c2j_count_user.GetFieldID;
  printf("%7u %7u %s\n", count, count_user, "GetFieldID");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetObjectField;
  count_user = bda_c2j_count_user.GetObjectField;
  printf("%7u %7u %s\n", count, count_user, "GetObjectField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetBooleanField;
  count_user = bda_c2j_count_user.GetBooleanField;
  printf("%7u %7u %s\n", count, count_user, "GetBooleanField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetByteField;
  count_user = bda_c2j_count_user.GetByteField;
  printf("%7u %7u %s\n", count, count_user, "GetByteField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetCharField;
  count_user = bda_c2j_count_user.GetCharField;
  printf("%7u %7u %s\n", count, count_user, "GetCharField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetShortField;
  count_user = bda_c2j_count_user.GetShortField;
  printf("%7u %7u %s\n", count, count_user, "GetShortField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetIntField;
  count_user = bda_c2j_count_user.GetIntField;
  printf("%7u %7u %s\n", count, count_user, "GetIntField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetLongField;
  count_user = bda_c2j_count_user.GetLongField;
  printf("%7u %7u %s\n", count, count_user, "GetLongField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetFloatField;
  count_user = bda_c2j_count_user.GetFloatField;
  printf("%7u %7u %s\n", count, count_user, "GetFloatField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetDoubleField;
  count_user = bda_c2j_count_user.GetDoubleField;
  printf("%7u %7u %s\n", count, count_user, "GetDoubleField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetObjectField;
  count_user = bda_c2j_count_user.SetObjectField;
  printf("%7u %7u %s\n", count, count_user, "SetObjectField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetBooleanField;
  count_user = bda_c2j_count_user.SetBooleanField;
  printf("%7u %7u %s\n", count, count_user, "SetBooleanField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetByteField;
  count_user = bda_c2j_count_user.SetByteField;
  printf("%7u %7u %s\n", count, count_user, "SetByteField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetCharField;
  count_user = bda_c2j_count_user.SetCharField;
  printf("%7u %7u %s\n", count, count_user, "SetCharField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetShortField;
  count_user = bda_c2j_count_user.SetShortField;
  printf("%7u %7u %s\n", count, count_user, "SetShortField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetIntField;
  count_user = bda_c2j_count_user.SetIntField;
  printf("%7u %7u %s\n", count, count_user, "SetIntField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetLongField;
  count_user = bda_c2j_count_user.SetLongField;
  printf("%7u %7u %s\n", count, count_user, "SetLongField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetFloatField;
  count_user = bda_c2j_count_user.SetFloatField;
  printf("%7u %7u %s\n", count, count_user, "SetFloatField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetDoubleField;
  count_user = bda_c2j_count_user.SetDoubleField;
  printf("%7u %7u %s\n", count, count_user, "SetDoubleField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticMethodID;
  count_user = bda_c2j_count_user.GetStaticMethodID;
  printf("%7u %7u %s\n", count, count_user, "GetStaticMethodID");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticObjectMethod;
  count_user = bda_c2j_count_user.CallStaticObjectMethod;
  printf("%7u %7u %s\n", count, count_user, "CallStaticObjectMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticObjectMethodV;
  count_user = bda_c2j_count_user.CallStaticObjectMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallStaticObjectMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticObjectMethodA;
  count_user = bda_c2j_count_user.CallStaticObjectMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallStaticObjectMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticBooleanMethod;
  count_user = bda_c2j_count_user.CallStaticBooleanMethod;
  printf("%7u %7u %s\n", count, count_user, "CallStaticBooleanMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticBooleanMethodV;
  count_user = bda_c2j_count_user.CallStaticBooleanMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallStaticBooleanMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticBooleanMethodA;
  count_user = bda_c2j_count_user.CallStaticBooleanMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallStaticBooleanMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticByteMethod;
  count_user = bda_c2j_count_user.CallStaticByteMethod;
  printf("%7u %7u %s\n", count, count_user, "CallStaticByteMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticByteMethodV;
  count_user = bda_c2j_count_user.CallStaticByteMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallStaticByteMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticByteMethodA;
  count_user = bda_c2j_count_user.CallStaticByteMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallStaticByteMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticCharMethod;
  count_user = bda_c2j_count_user.CallStaticCharMethod;
  printf("%7u %7u %s\n", count, count_user, "CallStaticCharMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticCharMethodV;
  count_user = bda_c2j_count_user.CallStaticCharMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallStaticCharMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticCharMethodA;
  count_user = bda_c2j_count_user.CallStaticCharMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallStaticCharMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticShortMethod;
  count_user = bda_c2j_count_user.CallStaticShortMethod;
  printf("%7u %7u %s\n", count, count_user, "CallStaticShortMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticShortMethodV;
  count_user = bda_c2j_count_user.CallStaticShortMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallStaticShortMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticShortMethodA;
  count_user = bda_c2j_count_user.CallStaticShortMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallStaticShortMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticIntMethod;
  count_user = bda_c2j_count_user.CallStaticIntMethod;
  printf("%7u %7u %s\n", count, count_user, "CallStaticIntMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticIntMethodV;
  count_user = bda_c2j_count_user.CallStaticIntMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallStaticIntMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticIntMethodA;
  count_user = bda_c2j_count_user.CallStaticIntMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallStaticIntMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticLongMethod;
  count_user = bda_c2j_count_user.CallStaticLongMethod;
  printf("%7u %7u %s\n", count, count_user, "CallStaticLongMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticLongMethodV;
  count_user = bda_c2j_count_user.CallStaticLongMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallStaticLongMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticLongMethodA;
  count_user = bda_c2j_count_user.CallStaticLongMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallStaticLongMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticFloatMethod;
  count_user = bda_c2j_count_user.CallStaticFloatMethod;
  printf("%7u %7u %s\n", count, count_user, "CallStaticFloatMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticFloatMethodV;
  count_user = bda_c2j_count_user.CallStaticFloatMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallStaticFloatMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticFloatMethodA;
  count_user = bda_c2j_count_user.CallStaticFloatMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallStaticFloatMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticDoubleMethod;
  count_user = bda_c2j_count_user.CallStaticDoubleMethod;
  printf("%7u %7u %s\n", count, count_user, "CallStaticDoubleMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticDoubleMethodV;
  count_user = bda_c2j_count_user.CallStaticDoubleMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallStaticDoubleMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticDoubleMethodA;
  count_user = bda_c2j_count_user.CallStaticDoubleMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallStaticDoubleMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticVoidMethod;
  count_user = bda_c2j_count_user.CallStaticVoidMethod;
  printf("%7u %7u %s\n", count, count_user, "CallStaticVoidMethod");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticVoidMethodV;
  count_user = bda_c2j_count_user.CallStaticVoidMethodV;
  printf("%7u %7u %s\n", count, count_user, "CallStaticVoidMethodV");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.CallStaticVoidMethodA;
  count_user = bda_c2j_count_user.CallStaticVoidMethodA;
  printf("%7u %7u %s\n", count, count_user, "CallStaticVoidMethodA");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticFieldID;
  count_user = bda_c2j_count_user.GetStaticFieldID;
  printf("%7u %7u %s\n", count, count_user, "GetStaticFieldID");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticObjectField;
  count_user = bda_c2j_count_user.GetStaticObjectField;
  printf("%7u %7u %s\n", count, count_user, "GetStaticObjectField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticBooleanField;
  count_user = bda_c2j_count_user.GetStaticBooleanField;
  printf("%7u %7u %s\n", count, count_user, "GetStaticBooleanField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticByteField;
  count_user = bda_c2j_count_user.GetStaticByteField;
  printf("%7u %7u %s\n", count, count_user, "GetStaticByteField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticCharField;
  count_user = bda_c2j_count_user.GetStaticCharField;
  printf("%7u %7u %s\n", count, count_user, "GetStaticCharField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticShortField;
  count_user = bda_c2j_count_user.GetStaticShortField;
  printf("%7u %7u %s\n", count, count_user, "GetStaticShortField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticIntField;
  count_user = bda_c2j_count_user.GetStaticIntField;
  printf("%7u %7u %s\n", count, count_user, "GetStaticIntField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticLongField;
  count_user = bda_c2j_count_user.GetStaticLongField;
  printf("%7u %7u %s\n", count, count_user, "GetStaticLongField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticFloatField;
  count_user = bda_c2j_count_user.GetStaticFloatField;
  printf("%7u %7u %s\n", count, count_user, "GetStaticFloatField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStaticDoubleField;
  count_user = bda_c2j_count_user.GetStaticDoubleField;
  printf("%7u %7u %s\n", count, count_user, "GetStaticDoubleField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetStaticObjectField;
  count_user = bda_c2j_count_user.SetStaticObjectField;
  printf("%7u %7u %s\n", count, count_user, "SetStaticObjectField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetStaticBooleanField;
  count_user = bda_c2j_count_user.SetStaticBooleanField;
  printf("%7u %7u %s\n", count, count_user, "SetStaticBooleanField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetStaticByteField;
  count_user = bda_c2j_count_user.SetStaticByteField;
  printf("%7u %7u %s\n", count, count_user, "SetStaticByteField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetStaticCharField;
  count_user = bda_c2j_count_user.SetStaticCharField;
  printf("%7u %7u %s\n", count, count_user, "SetStaticCharField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetStaticShortField;
  count_user = bda_c2j_count_user.SetStaticShortField;
  printf("%7u %7u %s\n", count, count_user, "SetStaticShortField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetStaticIntField;
  count_user = bda_c2j_count_user.SetStaticIntField;
  printf("%7u %7u %s\n", count, count_user, "SetStaticIntField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetStaticLongField;
  count_user = bda_c2j_count_user.SetStaticLongField;
  printf("%7u %7u %s\n", count, count_user, "SetStaticLongField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetStaticFloatField;
  count_user = bda_c2j_count_user.SetStaticFloatField;
  printf("%7u %7u %s\n", count, count_user, "SetStaticFloatField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetStaticDoubleField;
  count_user = bda_c2j_count_user.SetStaticDoubleField;
  printf("%7u %7u %s\n", count, count_user, "SetStaticDoubleField");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewString;
  count_user = bda_c2j_count_user.NewString;
  printf("%7u %7u %s\n", count, count_user, "NewString");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStringLength;
  count_user = bda_c2j_count_user.GetStringLength;
  printf("%7u %7u %s\n", count, count_user, "GetStringLength");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStringChars;
  count_user = bda_c2j_count_user.GetStringChars;
  printf("%7u %7u %s\n", count, count_user, "GetStringChars");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseStringChars;
  count_user = bda_c2j_count_user.ReleaseStringChars;
  printf("%7u %7u %s\n", count, count_user, "ReleaseStringChars");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewStringUTF;
  count_user = bda_c2j_count_user.NewStringUTF;
  printf("%7u %7u %s\n", count, count_user, "NewStringUTF");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStringUTFLength;
  count_user = bda_c2j_count_user.GetStringUTFLength;
  printf("%7u %7u %s\n", count, count_user, "GetStringUTFLength");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStringUTFChars;
  count_user = bda_c2j_count_user.GetStringUTFChars;
  printf("%7u %7u %s\n", count, count_user, "GetStringUTFChars");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseStringUTFChars;
  count_user = bda_c2j_count_user.ReleaseStringUTFChars;
  printf("%7u %7u %s\n", count, count_user, "ReleaseStringUTFChars");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetArrayLength;
  count_user = bda_c2j_count_user.GetArrayLength;
  printf("%7u %7u %s\n", count, count_user, "GetArrayLength");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewObjectArray;
  count_user = bda_c2j_count_user.NewObjectArray;
  printf("%7u %7u %s\n", count, count_user, "NewObjectArray");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetObjectArrayElement;
  count_user = bda_c2j_count_user.GetObjectArrayElement;
  printf("%7u %7u %s\n", count, count_user, "GetObjectArrayElement");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetObjectArrayElement;
  count_user = bda_c2j_count_user.SetObjectArrayElement;
  printf("%7u %7u %s\n", count, count_user, "SetObjectArrayElement");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewBooleanArray;
  count_user = bda_c2j_count_user.NewBooleanArray;
  printf("%7u %7u %s\n", count, count_user, "NewBooleanArray");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewByteArray;
  count_user = bda_c2j_count_user.NewByteArray;
  printf("%7u %7u %s\n", count, count_user, "NewByteArray");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewCharArray;
  count_user = bda_c2j_count_user.NewCharArray;
  printf("%7u %7u %s\n", count, count_user, "NewCharArray");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewShortArray;
  count_user = bda_c2j_count_user.NewShortArray;
  printf("%7u %7u %s\n", count, count_user, "NewShortArray");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewIntArray;
  count_user = bda_c2j_count_user.NewIntArray;
  printf("%7u %7u %s\n", count, count_user, "NewIntArray");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewLongArray;
  count_user = bda_c2j_count_user.NewLongArray;
  printf("%7u %7u %s\n", count, count_user, "NewLongArray");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewFloatArray;
  count_user = bda_c2j_count_user.NewFloatArray;
  printf("%7u %7u %s\n", count, count_user, "NewFloatArray");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewDoubleArray;
  count_user = bda_c2j_count_user.NewDoubleArray;
  printf("%7u %7u %s\n", count, count_user, "NewDoubleArray");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetBooleanArrayElements;
  count_user = bda_c2j_count_user.GetBooleanArrayElements;
  printf("%7u %7u %s\n", count, count_user, "GetBooleanArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetByteArrayElements;
  count_user = bda_c2j_count_user.GetByteArrayElements;
  printf("%7u %7u %s\n", count, count_user, "GetByteArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetCharArrayElements;
  count_user = bda_c2j_count_user.GetCharArrayElements;
  printf("%7u %7u %s\n", count, count_user, "GetCharArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetShortArrayElements;
  count_user = bda_c2j_count_user.GetShortArrayElements;
  printf("%7u %7u %s\n", count, count_user, "GetShortArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetIntArrayElements;
  count_user = bda_c2j_count_user.GetIntArrayElements;
  printf("%7u %7u %s\n", count, count_user, "GetIntArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetLongArrayElements;
  count_user = bda_c2j_count_user.GetLongArrayElements;
  printf("%7u %7u %s\n", count, count_user, "GetLongArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetFloatArrayElements;
  count_user = bda_c2j_count_user.GetFloatArrayElements;
  printf("%7u %7u %s\n", count, count_user, "GetFloatArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetDoubleArrayElements;
  count_user = bda_c2j_count_user.GetDoubleArrayElements;
  printf("%7u %7u %s\n", count, count_user, "GetDoubleArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseBooleanArrayElements;
  count_user = bda_c2j_count_user.ReleaseBooleanArrayElements;
  printf("%7u %7u %s\n", count, count_user, "ReleaseBooleanArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseByteArrayElements;
  count_user = bda_c2j_count_user.ReleaseByteArrayElements;
  printf("%7u %7u %s\n", count, count_user, "ReleaseByteArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseCharArrayElements;
  count_user = bda_c2j_count_user.ReleaseCharArrayElements;
  printf("%7u %7u %s\n", count, count_user, "ReleaseCharArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseShortArrayElements;
  count_user = bda_c2j_count_user.ReleaseShortArrayElements;
  printf("%7u %7u %s\n", count, count_user, "ReleaseShortArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseIntArrayElements;
  count_user = bda_c2j_count_user.ReleaseIntArrayElements;
  printf("%7u %7u %s\n", count, count_user, "ReleaseIntArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseLongArrayElements;
  count_user = bda_c2j_count_user.ReleaseLongArrayElements;
  printf("%7u %7u %s\n", count, count_user, "ReleaseLongArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseFloatArrayElements;
  count_user = bda_c2j_count_user.ReleaseFloatArrayElements;
  printf("%7u %7u %s\n", count, count_user, "ReleaseFloatArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseDoubleArrayElements;
  count_user = bda_c2j_count_user.ReleaseDoubleArrayElements;
  printf("%7u %7u %s\n", count, count_user, "ReleaseDoubleArrayElements");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetBooleanArrayRegion;
  count_user = bda_c2j_count_user.GetBooleanArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "GetBooleanArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetByteArrayRegion;
  count_user = bda_c2j_count_user.GetByteArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "GetByteArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetCharArrayRegion;
  count_user = bda_c2j_count_user.GetCharArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "GetCharArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetShortArrayRegion;
  count_user = bda_c2j_count_user.GetShortArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "GetShortArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetIntArrayRegion;
  count_user = bda_c2j_count_user.GetIntArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "GetIntArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetLongArrayRegion;
  count_user = bda_c2j_count_user.GetLongArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "GetLongArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetFloatArrayRegion;
  count_user = bda_c2j_count_user.GetFloatArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "GetFloatArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetDoubleArrayRegion;
  count_user = bda_c2j_count_user.GetDoubleArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "GetDoubleArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetBooleanArrayRegion;
  count_user = bda_c2j_count_user.SetBooleanArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "SetBooleanArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetByteArrayRegion;
  count_user = bda_c2j_count_user.SetByteArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "SetByteArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetCharArrayRegion;
  count_user = bda_c2j_count_user.SetCharArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "SetCharArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetShortArrayRegion;
  count_user = bda_c2j_count_user.SetShortArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "SetShortArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetIntArrayRegion;
  count_user = bda_c2j_count_user.SetIntArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "SetIntArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetLongArrayRegion;
  count_user = bda_c2j_count_user.SetLongArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "SetLongArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetFloatArrayRegion;
  count_user = bda_c2j_count_user.SetFloatArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "SetFloatArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.SetDoubleArrayRegion;
  count_user = bda_c2j_count_user.SetDoubleArrayRegion;
  printf("%7u %7u %s\n", count, count_user, "SetDoubleArrayRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.RegisterNatives;
  count_user = bda_c2j_count_user.RegisterNatives;
  printf("%7u %7u %s\n", count, count_user, "RegisterNatives");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.UnregisterNatives;
  count_user = bda_c2j_count_user.UnregisterNatives;
  printf("%7u %7u %s\n", count, count_user, "UnregisterNatives");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.MonitorEnter;
  count_user = bda_c2j_count_user.MonitorEnter;
  printf("%7u %7u %s\n", count, count_user, "MonitorEnter");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.MonitorExit;
  count_user = bda_c2j_count_user.MonitorExit;
  printf("%7u %7u %s\n", count, count_user, "MonitorExit");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetJavaVM;
  count_user = bda_c2j_count_user.GetJavaVM;
  printf("%7u %7u %s\n", count, count_user, "GetJavaVM");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStringRegion;
  count_user = bda_c2j_count_user.GetStringRegion;
  printf("%7u %7u %s\n", count, count_user, "GetStringRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStringUTFRegion;
  count_user = bda_c2j_count_user.GetStringUTFRegion;
  printf("%7u %7u %s\n", count, count_user, "GetStringUTFRegion");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetPrimitiveArrayCritical;
  count_user = bda_c2j_count_user.GetPrimitiveArrayCritical;
  printf("%7u %7u %s\n", count, count_user, "GetPrimitiveArrayCritical");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleasePrimitiveArrayCritical;
  count_user = bda_c2j_count_user.ReleasePrimitiveArrayCritical;
  printf("%7u %7u %s\n", count, count_user, "ReleasePrimitiveArrayCritical");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetStringCritical;
  count_user = bda_c2j_count_user.GetStringCritical;
  printf("%7u %7u %s\n", count, count_user, "GetStringCritical");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ReleaseStringCritical;
  count_user = bda_c2j_count_user.ReleaseStringCritical;
  printf("%7u %7u %s\n", count, count_user, "ReleaseStringCritical");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewWeakGlobalRef;
  count_user = bda_c2j_count_user.NewWeakGlobalRef;
  printf("%7u %7u %s\n", count, count_user, "NewWeakGlobalRef");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.DeleteWeakGlobalRef;
  count_user = bda_c2j_count_user.DeleteWeakGlobalRef;
  printf("%7u %7u %s\n", count, count_user, "DeleteWeakGlobalRef");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.ExceptionCheck;
  count_user = bda_c2j_count_user.ExceptionCheck;
  printf("%7u %7u %s\n", count, count_user, "ExceptionCheck");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.NewDirectByteBuffer;
  count_user = bda_c2j_count_user.NewDirectByteBuffer;
  printf("%7u %7u %s\n", count, count_user, "NewDirectByteBuffer");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetDirectBufferAddress;
  count_user = bda_c2j_count_user.GetDirectBufferAddress;
  printf("%7u %7u %s\n", count, count_user, "GetDirectBufferAddress");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetDirectBufferCapacity;
  count_user = bda_c2j_count_user.GetDirectBufferCapacity;
  printf("%7u %7u %s\n", count, count_user, "GetDirectBufferCapacity");
  sum += count;
  sum_user += count_user;

  count = bda_c2j_count.GetObjectRefType;
  count_user = bda_c2j_count_user.GetObjectRefType;
  printf("%7u %7u %s\n", count, count_user, "GetObjectRefType");
  sum += count;
  sum_user += count_user;
  printf("%7u %7u All JNI functions\n", sum, sum_user);
}
